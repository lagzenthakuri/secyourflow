import { EpssAdapter } from "../adapters/epss-adapter";
import { KevAdapter } from "../adapters/kev-adapter";
import { NvdAdapter } from "../adapters/nvd-adapter";
import { TtlCache, RequestCoalescer, stableCacheKey } from "../cache/memory-cache";
import { dedupeAndMergeCves } from "../domain/dedupe";
import { applySearchFilters, paginate } from "../domain/filtering";
import { normalizeCveId } from "../domain/normalize";
import { parseCveSearchQuery, type ParsedCveSearchQuery } from "../domain/query-parser";
import { normalizeSearchQueryKey } from "../domain/query";
import { detailResponseSchema, searchResponseSchema } from "../domain/schemas";
import { rankCves } from "../domain/ranking";
import { validateNormalizedCves } from "../domain/validation";
import type {
  DetailResponse,
  SearchQuery,
  SearchResponse,
  CveSearchConfig,
  NormalizedCve,
} from "../domain/types";
import { CircuitBreakerRegistry } from "./circuit-breaker";
import { getCveSearchConfig } from "./config";
import { CveEnricher } from "./enricher";
import { collectSourceValues, createAbortController, elapsedMs } from "./helpers";
import { logEvent } from "./log";
import { incrementCounter, recordTiming } from "./metrics";
import { runSourceCall } from "./source-runner";

function toUpstreamQuery(parsedQuery: ParsedCveSearchQuery): string {
  if (parsedQuery.kind === "cveId") {
    return normalizeCveId(parsedQuery.includeTerms[0] ?? parsedQuery.raw);
  }

  if (parsedQuery.includeTerms.length > 0) {
    return parsedQuery.includeTerms.join(" ");
  }

  return parsedQuery.raw;
}

function toRankingQuery(parsedQuery: ParsedCveSearchQuery): string {
  if (parsedQuery.kind === "cveId") {
    return parsedQuery.includeTerms[0] ?? parsedQuery.raw;
  }

  if (parsedQuery.kind === "product" && parsedQuery.includeTerms.length > 0) {
    return parsedQuery.includeTerms.join(" ");
  }

  return parsedQuery.raw;
}

export class CveSearchService {
  private readonly config: CveSearchConfig;
  private readonly nvdAdapter: NvdAdapter;
  private readonly enricher: CveEnricher | null;
  private readonly searchCache = new TtlCache<SearchResponse>(300);
  private readonly detailCache = new TtlCache<DetailResponse>(400);
  private readonly coalescer = new RequestCoalescer();
  private readonly circuit: CircuitBreakerRegistry;

  constructor(config?: CveSearchConfig, fetchImpl?: typeof fetch) {
    this.config = config ?? getCveSearchConfig();
    this.circuit = new CircuitBreakerRegistry(
      this.config.circuitBreaker.failureThreshold,
      this.config.circuitBreaker.openMs,
    );

    const context = {
      config: this.config,
      fetchImpl,
    };

    this.nvdAdapter = new NvdAdapter(context);
    if (this.config.enrichment.enabled) {
      this.enricher = new CveEnricher({
        config: this.config,
        circuit: this.circuit,
        coalescer: this.coalescer,
        kevAdapter: new KevAdapter(context),
        epssAdapter: new EpssAdapter(context),
      });
    } else {
      this.enricher = null;
    }
  }

  async search(query: SearchQuery): Promise<SearchResponse> {
    return this.runCachedSearch(query);
  }

  async getById(cveId: string): Promise<DetailResponse | null> {
    return this.runCachedDetail(cveId);
  }

  private async runCachedSearch(query: SearchQuery): Promise<SearchResponse> {
    const key = stableCacheKey("search", {
      q: normalizeSearchQueryKey(query),
    });

    const cached = this.searchCache.get(key);
    if (cached) {
      incrementCounter("cve_search_cache_hit_search");
      return cached;
    }

    incrementCounter("cve_search_cache_miss_search");

    return this.coalescer.run(key, async () => {
      const secondCheck = this.searchCache.get(key);
      if (secondCheck) {
        return secondCheck;
      }

      const startedAt = Date.now();
      const overall = createAbortController(this.config.timeouts.overallRequestMs);
      const warnings: string[] = [];
      const sourcesUsed = new Set<string>();
      let partial = false;
      const parsedQuery = parseCveSearchQuery(query.q, query.mode);
      const isEmptyQuery = parsedQuery.raw.length === 0;

      if (isEmptyQuery) {
        const emptyResponse = searchResponseSchema.parse({
          meta: {
            query: query.q,
            page: query.page,
            pageSize: query.pageSize,
            tookMs: elapsedMs(startedAt),
            sourcesUsed: [],
            partial: false,
            warnings: [],
          },
          data: [],
        });

        this.searchCache.set(key, emptyResponse, this.config.cacheTtlMs.searchResults);
        overall.dispose();
        return emptyResponse;
      }

      try {
        const sourceCves = await this.collectSearchCandidates(
          query,
          parsedQuery,
          warnings,
          sourcesUsed,
          overall.signal,
        );
        const deduped = dedupeAndMergeCves(sourceCves);
        const valid = validateNormalizedCves(deduped, warnings);
        const enriched = await this.enrichIfEnabled(valid, warnings, sourcesUsed, overall.signal);
        const filtered = applySearchFilters(enriched, query, parsedQuery);
        const ranked = rankCves(filtered, query.sort, toRankingQuery(parsedQuery), parsedQuery);
        const data = paginate(ranked, query.page, query.pageSize);

        partial = warnings.length > 0;

        const response: SearchResponse = {
          meta: {
            query: query.q,
            page: query.page,
            pageSize: query.pageSize,
            tookMs: elapsedMs(startedAt),
            sourcesUsed: Array.from(sourcesUsed.values()),
            partial,
            warnings,
          },
          data,
        };

        const validated = searchResponseSchema.parse(response);
        this.searchCache.set(key, validated, this.config.cacheTtlMs.searchResults);
        recordTiming("cve_search_search_ms", elapsedMs(startedAt));
        return validated;
      } catch (error) {
        const message = error instanceof Error ? error.message : "Search failed";
        logEvent("error", "search_failed", { message });

        const fallback = searchResponseSchema.parse({
          meta: {
            query: query.q,
            page: query.page,
            pageSize: query.pageSize,
            tookMs: elapsedMs(startedAt),
            sourcesUsed: Array.from(sourcesUsed.values()),
            partial: true,
            warnings: [...warnings, message],
          },
          data: [],
        });

        this.searchCache.set(key, fallback, this.config.cacheTtlMs.searchResults);
        return fallback;
      } finally {
        overall.dispose();
      }
    });
  }

  private async runCachedDetail(cveId: string): Promise<DetailResponse | null> {
    const normalizedId = normalizeCveId(cveId);
    const key = stableCacheKey("detail", { cveId: normalizedId });
    const cached = this.detailCache.get(key);
    if (cached) {
      incrementCounter("cve_search_cache_hit_detail");
      return cached;
    }

    incrementCounter("cve_search_cache_miss_detail");

    return this.coalescer.run(key, async () => {
      const secondCheck = this.detailCache.get(key);
      if (secondCheck) {
        return secondCheck;
      }

      const startedAt = Date.now();
      const overall = createAbortController(this.config.timeouts.overallRequestMs);
      const warnings: string[] = [];
      const sourcesUsed = new Set<string>();

      try {
        const candidates = await this.collectDetailCandidates(normalizedId, warnings, sourcesUsed, overall.signal);
        const deduped = dedupeAndMergeCves(candidates);

        if (deduped.length === 0) {
          return null;
        }

        const validated = validateNormalizedCves(deduped, warnings);
        const enriched = await this.enrichIfEnabled(validated, warnings, sourcesUsed, overall.signal);
        const selected = rankCves(enriched, "relevance", normalizedId)[0];

        if (!selected) {
          return null;
        }

        const response = detailResponseSchema.parse({
          meta: {
            cveId: normalizedId,
            tookMs: elapsedMs(startedAt),
            sourcesUsed: Array.from(sourcesUsed.values()),
            partial: warnings.length > 0,
            warnings,
          },
          data: selected,
        });

        this.detailCache.set(key, response, this.config.cacheTtlMs.cveById);
        recordTiming("cve_search_get_by_id_ms", elapsedMs(startedAt));
        return response;
      } finally {
        overall.dispose();
      }
    });
  }

  private async collectSearchCandidates(
    query: SearchQuery,
    parsedQuery: ParsedCveSearchQuery,
    warnings: string[],
    sourcesUsed: Set<string>,
    signal: AbortSignal,
  ): Promise<NormalizedCve[]> {
    const requestedWindowSize =
      parsedQuery.kind === "cveId"
        ? 1
        : Math.max(query.page * query.pageSize * 2, query.pageSize + 1);
    const upstreamQuery = toUpstreamQuery(parsedQuery);
    const sourceOptions = {
      // Always fetch from the first upstream page so local ranking + pagination stays consistent.
      page: 1,
      pageSize:
        parsedQuery.kind === "cveId"
          ? 1
          : Math.min(200, Math.max(requestedWindowSize, query.pageSize)),
      from: query.from,
      to: query.to,
      signal,
    };

    const nvdResult = await runSourceCall({
      source: "nvd",
      circuit: this.circuit,
      action: async () => {
        const result = await this.nvdAdapter.search(upstreamQuery, sourceOptions);
        return { value: result.cves, warnings: result.warnings };
      },
    });

    return collectSourceValues([nvdResult], warnings, sourcesUsed);
  }

  private async collectDetailCandidates(
    cveId: string,
    warnings: string[],
    sourcesUsed: Set<string>,
    signal: AbortSignal,
  ): Promise<NormalizedCve[]> {
    const nvdResult = await runSourceCall({
      source: "nvd",
      circuit: this.circuit,
      action: async () => {
        const result = await this.nvdAdapter.getById(cveId, signal);
        return { value: result.cve ? [result.cve] : [], warnings: result.warnings };
      },
    });

    return collectSourceValues([nvdResult], warnings, sourcesUsed);
  }

  private async enrichIfEnabled(
    cves: NormalizedCve[],
    warnings: string[],
    sourcesUsed: Set<string>,
    signal: AbortSignal,
  ): Promise<NormalizedCve[]> {
    if (!this.enricher || cves.length === 0) {
      return cves;
    }

    try {
      return await this.enricher.enrich(cves, warnings, sourcesUsed, signal);
    } catch (error) {
      warnings.push(
        `enrichment failed: ${error instanceof Error ? error.message : "unknown enrichment failure"}`,
      );
      return cves;
    }
  }
}

let singleton: CveSearchService | null = null;

export function getCveSearchService(): CveSearchService {
  singleton ??= new CveSearchService();
  return singleton;
}

export function resetCveSearchServiceSingleton(): void {
  singleton = null;
}
