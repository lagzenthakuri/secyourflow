import { incrementCounter } from "./metrics";

export interface FetchWithResilienceOptions {
  source: string;
  url: string;
  init?: RequestInit;
  signal?: AbortSignal;
  timeoutMs: number;
  maxRetries: number;
  baseBackoffMs: number;
  fetchImpl?: typeof fetch;
  sleepImpl?: (ms: number) => Promise<void>;
}

const DEFAULT_SLEEP = (ms: number) => new Promise<void>((resolve) => setTimeout(resolve, ms));

function parseRetryAfterMs(value: string | null): number | null {
  if (!value) {
    return null;
  }

  const asSeconds = Number(value);
  if (Number.isFinite(asSeconds) && asSeconds >= 0) {
    return Math.round(asSeconds * 1_000);
  }

  const parsedDate = new Date(value);
  if (Number.isNaN(parsedDate.getTime())) {
    return null;
  }

  return Math.max(0, parsedDate.getTime() - Date.now());
}

function combineSignals(signals: Array<AbortSignal | undefined>): AbortSignal | undefined {
  const activeSignals = signals.filter(Boolean) as AbortSignal[];
  if (activeSignals.length === 0) {
    return undefined;
  }

  if (activeSignals.length === 1) {
    return activeSignals[0];
  }

  const controller = new AbortController();

  const abort = (event: Event) => {
    const target = event.target as AbortSignal;
    controller.abort(target.reason);
  };

  for (const signal of activeSignals) {
    if (signal.aborted) {
      controller.abort(signal.reason);
      return controller.signal;
    }
    signal.addEventListener("abort", abort, { once: true });
  }

  return controller.signal;
}

function withTimeout(timeoutMs: number): { signal: AbortSignal; dispose: () => void } {
  const controller = new AbortController();
  const timeout = setTimeout(() => {
    controller.abort(new Error(`Request timed out after ${timeoutMs}ms`));
  }, timeoutMs);

  return {
    signal: controller.signal,
    dispose: () => clearTimeout(timeout),
  };
}

function shouldRetry(response: Response): boolean {
  if (response.status === 429) {
    return true;
  }

  return response.status >= 500;
}

function deterministicJitter(seed: string, attempt: number): number {
  let hash = 0;
  const value = `${seed}:${attempt}`;

  for (let index = 0; index < value.length; index += 1) {
    hash = (hash << 5) - hash + value.charCodeAt(index);
    hash |= 0;
  }

  return Math.abs(hash % 25);
}

export function computeBackoffMs(baseBackoffMs: number, attempt: number, seed: string): number {
  const exponential = baseBackoffMs * 2 ** Math.max(0, attempt - 1);
  return exponential + deterministicJitter(seed, attempt);
}

export async function fetchWithResilience(
  options: FetchWithResilienceOptions,
): Promise<Response> {
  const fetchImpl = options.fetchImpl ?? fetch;
  const sleepImpl = options.sleepImpl ?? DEFAULT_SLEEP;

  let attempt = 0;
  let lastError: Error | null = null;

  while (attempt <= options.maxRetries) {
    attempt += 1;

    const timeoutController = withTimeout(options.timeoutMs);
    const signal = combineSignals([options.signal, timeoutController.signal]);

    try {
      const response = await fetchImpl(options.url, {
        ...options.init,
        signal,
      });

      timeoutController.dispose();

      if (!shouldRetry(response) || attempt > options.maxRetries) {
        return response;
      }

      incrementCounter(`cve_search_retry_${options.source}`);

      const retryAfter = parseRetryAfterMs(response.headers.get("Retry-After"));
      const sleepMs = retryAfter ?? computeBackoffMs(options.baseBackoffMs, attempt, options.url);
      await sleepImpl(sleepMs);
    } catch (error) {
      timeoutController.dispose();
      const normalizedError = error instanceof Error ? error : new Error(String(error));
      lastError = normalizedError;

      if (attempt > options.maxRetries) {
        break;
      }

      incrementCounter(`cve_search_retry_${options.source}`);
      const sleepMs = computeBackoffMs(options.baseBackoffMs, attempt, options.url);
      await sleepImpl(sleepMs);
    }
  }

  throw lastError ?? new Error("Failed request without a response");
}

export async function fetchJsonWithResilience<T>(
  options: FetchWithResilienceOptions,
): Promise<{ status: number; data: T; headers: Headers }> {
  const response = await fetchWithResilience(options);

  const text = await response.text();
  const data = text.length > 0 ? (JSON.parse(text) as T) : ({} as T);

  return {
    status: response.status,
    data,
    headers: response.headers,
  };
}
