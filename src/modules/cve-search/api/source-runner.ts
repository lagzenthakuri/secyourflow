import { logEvent } from "./log";
import { incrementCounter } from "./metrics";
import { CircuitBreakerRegistry } from "./circuit-breaker";
import type { SourceSuccess } from "../domain/types";

export interface SourceRunnerOptions<T> {
  source: string;
  circuit: CircuitBreakerRegistry;
  action: () => Promise<{ value: T; warnings?: string[] }>;
}

export async function runSourceCall<T>(
  options: SourceRunnerOptions<T>,
): Promise<SourceSuccess<T> | null> {
  if (options.circuit.isOpen(options.source)) {
    incrementCounter(`cve_search_source_skipped_${options.source}`);
    logEvent("warn", "source_circuit_open", {
      source: options.source,
    });
    return null;
  }

  try {
    const response = await options.action();
    options.circuit.recordSuccess(options.source);

    return {
      source: options.source,
      value: response.value,
      warnings: response.warnings ?? [],
    };
  } catch (error) {
    options.circuit.recordFailure(options.source);
    incrementCounter(`cve_search_source_failure_${options.source}`);

    logEvent("warn", "source_failure", {
      source: options.source,
      message: error instanceof Error ? error.message : String(error),
    });

    return null;
  }
}
