import type { KevAdapter, KevEntry } from "../adapters/kev-adapter";
import type { EpssAdapter, EpssEntry } from "../adapters/epss-adapter";
import { RequestCoalescer, TtlCache, stableCacheKey } from "../cache/memory-cache";
import type { CveSearchConfig, NormalizedCve } from "../domain/types";
import { CircuitBreakerRegistry } from "./circuit-breaker";
import { runSourceCall } from "./source-runner";

interface EnricherDependencies {
  config: CveSearchConfig;
  circuit: CircuitBreakerRegistry;
  coalescer: RequestCoalescer;
  kevAdapter: KevAdapter;
  epssAdapter: EpssAdapter;
}

export class CveEnricher {
  private readonly kevCache = new TtlCache<Map<string, KevEntry>>(2);
  private readonly epssCache = new TtlCache<EpssEntry>(2_000);

  constructor(private readonly deps: EnricherDependencies) {}

  async enrich(
    cves: NormalizedCve[],
    warnings: string[],
    sourcesUsed: Set<string>,
    signal: AbortSignal,
  ): Promise<NormalizedCve[]> {
    if (cves.length === 0) {
      return cves;
    }

    const cveIds = cves.map((cve) => cve.cveId);

    const [kevMap, epssMap] = await Promise.all([
      this.getKevMap(cveIds, warnings, sourcesUsed, signal),
      this.getEpssMap(cveIds, warnings, sourcesUsed, signal),
    ]);

    return cves.map((cve) => {
      const kev = kevMap.get(cve.cveId);
      const epss = epssMap.get(cve.cveId);

      return {
        ...cve,
        kev: kev
          ? {
              isKnownExploited: true,
              dateAdded: kev.dateAdded,
              dueDate: kev.dueDate,
              notes: kev.notes,
            }
          : cve.kev,
        epss: epss
          ? {
              score: epss.score,
              percentile: epss.percentile,
              asOf: epss.asOf,
            }
          : cve.epss,
        sourceAttribution: kev
          ? [
              ...cve.sourceAttribution,
              {
                source: "CISA-KEV",
                url: "https://www.cisa.gov/known-exploited-vulnerabilities-catalog",
              },
            ]
          : cve.sourceAttribution,
      };
    });
  }

  private async getKevMap(
    cveIds: string[],
    warnings: string[],
    sourcesUsed: Set<string>,
    signal: AbortSignal,
  ): Promise<Map<string, KevEntry>> {
    const cacheKey = "kev:catalog";
    const cached = this.kevCache.get(cacheKey);
    if (cached) {
      sourcesUsed.add("CISA-KEV");
      return this.filterMapByIds(cached, cveIds);
    }

    const catalog = await this.deps.coalescer.run(cacheKey, async () => {
      const cacheAgain = this.kevCache.get(cacheKey);
      if (cacheAgain) {
        return cacheAgain;
      }

      const source = await runSourceCall({
        source: "kev",
        circuit: this.deps.circuit,
        action: async () => {
          const response = await this.deps.kevAdapter.getCatalog(signal);
          return {
            value: new Map(response.entries.map((entry) => [entry.cveId, entry])),
            warnings: response.warnings,
          };
        },
      });

      if (!source) {
        return new Map<string, KevEntry>();
      }

      if (source.warnings.length > 0) {
        warnings.push(...source.warnings.map((warning) => `kev: ${warning}`));
      }

      this.kevCache.set(cacheKey, source.value, this.deps.config.cacheTtlMs.kevCatalog);
      if (source.value.size > 0) {
        sourcesUsed.add("CISA-KEV");
      }

      return source.value;
    });

    return this.filterMapByIds(catalog, cveIds);
  }

  private async getEpssMap(
    cveIds: string[],
    warnings: string[],
    sourcesUsed: Set<string>,
    signal: AbortSignal,
  ): Promise<Map<string, EpssEntry>> {
    const byId = new Map<string, EpssEntry>();
    const missing: string[] = [];

    for (const id of cveIds) {
      const cached = this.epssCache.get(`epss:${id}`);
      if (cached) {
        byId.set(id, cached);
      } else {
        missing.push(id);
      }
    }

    if (missing.length === 0) {
      if (byId.size > 0) {
        sourcesUsed.add("EPSS");
      }
      return byId;
    }

    const batchKey = stableCacheKey("epss:batch", { ids: missing.slice().sort() });
    const fetched = await this.deps.coalescer.run(batchKey, async () => {
      const source = await runSourceCall({
        source: "epss",
        circuit: this.deps.circuit,
        action: async () => {
          const response = await this.deps.epssAdapter.getScores(missing, signal);
          return {
            value: response.byId,
            warnings: response.warnings,
          };
        },
      });

      if (!source) {
        return new Map<string, EpssEntry>();
      }

      if (source.warnings.length > 0) {
        warnings.push(...source.warnings.map((warning) => `epss: ${warning}`));
      }

      for (const [id, entry] of source.value.entries()) {
        this.epssCache.set(`epss:${id}`, entry, this.deps.config.cacheTtlMs.epssScores);
      }

      if (source.value.size > 0) {
        sourcesUsed.add("EPSS");
      }

      return source.value;
    });

    for (const [id, entry] of fetched.entries()) {
      byId.set(id, entry);
    }

    return byId;
  }

  private filterMapByIds<T>(map: Map<string, T>, ids: string[]): Map<string, T> {
    const filtered = new Map<string, T>();
    for (const id of ids) {
      const entry = map.get(id);
      if (entry) {
        filtered.set(id, entry);
      }
    }
    return filtered;
  }
}
