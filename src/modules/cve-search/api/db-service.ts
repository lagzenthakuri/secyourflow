import { Prisma, PrismaClient, Severity as PrismaSeverity } from "@prisma/client";
import type {
  DetailResponse,
  NormalizedCve,
  SearchQuery,
  SearchResponse,
  Severity,
} from "../domain/types";
import { logger } from "@/modules/cve-ingestion/utils/logger";

function mapPrismaSeverity(value: PrismaSeverity): Severity {
  switch (value) {
    case "CRITICAL":
      return "CRITICAL";
    case "HIGH":
      return "HIGH";
    case "MEDIUM":
      return "MEDIUM";
    case "LOW":
      return "LOW";
    default:
      return "UNKNOWN";
  }
}

function mapQuerySeverityToPrisma(value: SearchQuery["severity"]): PrismaSeverity | null {
  if (value === "CRITICAL" || value === "HIGH" || value === "MEDIUM" || value === "LOW") {
    return value;
  }

  return null;
}

export class CveDbService {
  constructor(private readonly prisma: PrismaClient) {}

  async search(query: SearchQuery): Promise<SearchResponse> {
    const startTime = Date.now();

    try {
      // Build where clause
      const where: Prisma.CveWhereInput = {
        status: "ACTIVE", // Exclude REJECTED by default
      };

      // Text search
      if (query.q) {
        where.OR = [
          { cveId: { contains: query.q, mode: "insensitive" } },
          { description: { contains: query.q, mode: "insensitive" } },
        ];
      }

      // Severity filter
      if (query.severity && query.severity !== "ALL") {
        const mapped = mapQuerySeverityToPrisma(query.severity);
        if (mapped) {
          where.severity = mapped;
        } else {
          where.cveId = "__NO_MATCH__";
        }
      }

      // KEV filter
      if (query.kev === "KEV_ONLY") {
        where.isKev = true;
      } else if (query.kev === "NOT_KEV") {
        where.isKev = false;
      }

      // EPSS filter
      const epssScoreFilter: Prisma.FloatNullableFilter<"Cve"> = {};
      if (query.epssMin !== undefined) {
        epssScoreFilter.gte = query.epssMin;
      }
      if (query.epssMax !== undefined) {
        epssScoreFilter.lte = query.epssMax;
      }
      if (query.epssMin !== undefined || query.epssMax !== undefined) {
        where.epssScore = epssScoreFilter;
      }

      // CVSS filter
      if (query.cvssMin !== undefined || query.cvssMax !== undefined) {
        const cvssWhere: Prisma.FloatFilter<"CveCvss"> = {};
        if (query.cvssMin !== undefined) cvssWhere.gte = query.cvssMin;
        if (query.cvssMax !== undefined) cvssWhere.lte = query.cvssMax;

        where.CveCvss = {
          some: {
            baseScore: cvssWhere,
          },
        };
      }

      // Date range
      if (query.from || query.to) {
        const publishedAt: Prisma.DateTimeFilter<"Cve"> = {};
        if (query.from) publishedAt.gte = new Date(query.from);
        if (query.to) publishedAt.lte = new Date(query.to);
        where.publishedAt = publishedAt;
      }

      // Build order by
      let orderBy: Prisma.CveOrderByWithRelationInput | Prisma.CveOrderByWithRelationInput[] = {};
      switch (query.sort) {
        case "newest":
          orderBy = { publishedAt: "desc" };
          break;
        case "cvss":
          orderBy = [{ isKev: "desc" }, { severity: "desc" }, { publishedAt: "desc" }];
          break;
        case "epss":
          orderBy = [{ isKev: "desc" }, { epssScore: "desc" }, { publishedAt: "desc" }];
          break;
        default:
          orderBy = [{ isKev: "desc" }, { epssScore: "desc" }, { severity: "desc" }, { publishedAt: "desc" }];
      }

      // Fetch results
      const skip = (query.page - 1) * query.pageSize;
      const cves = await this.prisma.cve.findMany({
        where,
        orderBy,
        skip,
        take: query.pageSize,
        include: {
          CveCvss: {
            orderBy: { version: "desc" },
            take: 1,
          },
          KevEntry: true,
        },
      });

      // Map to NormalizedCve format
      const results: NormalizedCve[] = cves.map((cve) => {
        const bestCvss = cve.CveCvss[0];
        
        return {
          cveId: cve.cveId,
          title: null,
          description: cve.description,
          published: cve.publishedAt.toISOString(),
          lastModified: cve.lastModifiedAt.toISOString(),
          severity: mapPrismaSeverity(cve.severity),
          cvss: {
            version: bestCvss?.version ?? null,
            baseScore: bestCvss?.baseScore ?? null,
            vector: bestCvss?.vectorString ?? null,
          },
          epss: {
            score: cve.epssScore,
            percentile: cve.epssPercentile,
            asOf: null,
          },
          kev: {
            isKnownExploited: cve.isKev,
            dateAdded: cve.KevEntry?.dateAdded?.toISOString() || null,
            dueDate: cve.KevEntry?.dueDate?.toISOString() || null,
            notes: cve.KevEntry?.notes || null,
          },
          affected: {
            cpe: [],
            packages: [],
          },
          references: [],
          sourceAttribution: [{ source: "Database" }],
        };
      });

      const tookMs = Date.now() - startTime;

      return {
        data: results,
        meta: {
          query: query.q,
          page: query.page,
          pageSize: query.pageSize,
          tookMs,
          sourcesUsed: ["Database"],
          partial: false,
          warnings: [],
        },
      };
    } catch (error) {
      logger.error("Database search failed", {
        error: error instanceof Error ? error.message : String(error),
      });

      throw error;
    }
  }

  async getById(cveId: string): Promise<DetailResponse | null> {
    try {
      const cve = await this.prisma.cve.findUnique({
        where: { cveId: cveId.toUpperCase() },
        include: {
          CveCvss: {
            orderBy: { version: "desc" },
          },
          CveCpe: true,
          CveReference: true,
          KevEntry: true,
        },
      });

      if (!cve) return null;

      const bestCvss = cve.CveCvss[0];

      return {
        data: {
          cveId: cve.cveId,
          title: null,
          description: cve.description,
          published: cve.publishedAt.toISOString(),
          lastModified: cve.lastModifiedAt.toISOString(),
          severity: mapPrismaSeverity(cve.severity),
          cvss: {
            version: bestCvss?.version ?? null,
            baseScore: bestCvss?.baseScore ?? null,
            vector: bestCvss?.vectorString ?? null,
          },
          epss: {
            score: cve.epssScore,
            percentile: cve.epssPercentile,
            asOf: null,
          },
          kev: {
            isKnownExploited: cve.isKev,
            dateAdded: cve.KevEntry?.dateAdded?.toISOString() || null,
            dueDate: cve.KevEntry?.dueDate?.toISOString() || null,
            notes: cve.KevEntry?.notes || null,
          },
          affected: {
            cpe: cve.CveCpe.map((c) => c.cpeUri),
            packages: [],
          },
          references: cve.CveReference.map((r) => ({
            url: r.url,
            source: r.source,
          })),
          sourceAttribution: [{ source: "Database" }],
        },
        meta: {
          cveId: cve.cveId,
          tookMs: 0,
          sourcesUsed: ["Database"],
          partial: false,
          warnings: [],
        },
      };
    } catch (error) {
      logger.error("Database getById failed", {
        cveId,
        error: error instanceof Error ? error.message : String(error),
      });

      throw error;
    }
  }
}
