import type { SearchQuery } from "./types";
import { searchQuerySchema } from "./schemas";

function parseSort(value: string | null): SearchQuery["sort"] | undefined {
  if (!value) return undefined;

  const normalized = value.toLowerCase();
  if (normalized === "relevance") return "relevance";
  if (normalized === "newest" || normalized === "published_desc" || normalized === "modified_desc") {
    return "newest";
  }
  if (normalized === "cvss" || normalized === "cvss_desc") return "cvss";
  if (normalized === "epss" || normalized === "epss_desc") return "epss";

  return undefined;
}

function parseRiskRange(value: string | null): { min?: number; max?: number } {
  if (!value) return {};
  if (value === "HIGH") return { min: 0.7, max: 1 };
  if (value === "MEDIUM") return { min: 0.3, max: 0.6999 };
  if (value === "LOW") return { min: 0, max: 0.2999 };
  return {};
}

function parseMode(value: string | null): SearchQuery["mode"] {
  if (!value) return "auto";

  const normalized = value.toLowerCase();
  if (normalized === "product" || normalized === "text" || normalized === "auto") {
    return normalized;
  }

  return "auto";
}

function parseYearRange(value: string | null): { from?: string; to?: string } {
  if (!value || value === "ALL") {
    return {};
  }

  const normalized = value.trim();
  const fullYear = /^\d{4}$/.test(normalized) ? Number(normalized) : null;

  let startYear: number | null = fullYear;
  let endYear: number | null = fullYear;

  if (normalized === "2010s") {
    startYear = 2010;
    endYear = 2019;
  } else if (normalized === "2000s") {
    startYear = 2000;
    endYear = 2009;
  } else if (normalized === "1999-2009") {
    startYear = 1999;
    endYear = 2009;
  }

  if (startYear === null || endYear === null) {
    return {};
  }

  return {
    from: new Date(`${startYear}-01-01T00:00:00.000Z`).toISOString(),
    to: new Date(`${endYear}-12-31T23:59:59.999Z`).toISOString(),
  };
}

function toIsoRangeStart(value: string | null): string | undefined {
  if (!value) return undefined;
  const date = new Date(`${value}T00:00:00.000Z`);
  return Number.isNaN(date.getTime()) ? undefined : date.toISOString();
}

function toIsoRangeEnd(value: string | null): string | undefined {
  if (!value) return undefined;
  const date = new Date(`${value}T23:59:59.999Z`);
  return Number.isNaN(date.getTime()) ? undefined : date.toISOString();
}

export function parseSearchQuery(params: URLSearchParams): SearchQuery {
  const epssRiskRange = parseRiskRange(params.get("epss_risk"));
  const yearRange = parseYearRange(params.get("year"));
  const fromValue =
    params.get("from") ??
    toIsoRangeStart(params.get("published_from")) ??
    toIsoRangeStart(params.get("modified_from")) ??
    yearRange.from;
  const toValue =
    params.get("to") ??
    toIsoRangeEnd(params.get("published_to")) ??
    toIsoRangeEnd(params.get("modified_to")) ??
    yearRange.to;

  const parsed = searchQuerySchema.parse({
    q: params.get("q") ?? params.get("cve_id") ?? "",
    mode: parseMode(params.get("mode")),
    page: params.get("page") ?? "1",
    pageSize: params.get("pageSize") ?? params.get("limit") ?? "20",
    from: fromValue,
    to: toValue,
    sort: parseSort(params.get("sort")) ?? "relevance",
    severity: params.get("severity") ?? undefined,
    kev: params.get("kev") ?? undefined,
    epssMin: params.get("epssMin") ?? params.get("epss_min") ?? epssRiskRange.min,
    epssMax: params.get("epssMax") ?? params.get("epss_max") ?? epssRiskRange.max,
    cvssMin: params.get("cvssMin") ?? params.get("cvss_min") ?? undefined,
    cvssMax: params.get("cvssMax") ?? params.get("cvss_max") ?? undefined,
  });

  return {
    ...parsed,
    q: parsed.q.trim(),
  };
}

export function normalizeSearchQueryKey(query: SearchQuery): string {
  const stable: Record<string, string | number | undefined> = {
    q: query.q.trim().toLowerCase(),
    mode: query.mode ?? "auto",
    page: query.page,
    pageSize: query.pageSize,
    sort: query.sort,
    from: query.from,
    to: query.to,
    severity: query.severity,
    kev: query.kev,
    epssMin: query.epssMin,
    epssMax: query.epssMax,
    cvssMin: query.cvssMin,
    cvssMax: query.cvssMax,
  };

  const keys = Object.keys(stable).sort();
  return keys
    .filter((key) => stable[key] !== undefined)
    .map((key) => `${key}:${stable[key]}`)
    .join("|");
}
