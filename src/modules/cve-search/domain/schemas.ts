import { z } from "zod";

const nullableIsoDate = z
  .string()
  .datetime({ offset: true })
  .or(z.string().datetime())
  .nullable();

export const severitySchema = z.enum([
  "LOW",
  "MEDIUM",
  "HIGH",
  "CRITICAL",
  "UNKNOWN",
]);

export const normalizedCveSchema = z
  .object({
    cveId: z.string().regex(/^CVE-\d{4}-\d{4,}$/i),
    title: z.string().nullable(),
    description: z.string(),
    published: nullableIsoDate,
    lastModified: nullableIsoDate,
    severity: severitySchema,
    cvss: z.object({
      version: z.string().nullable(),
      baseScore: z.number().min(0).max(10).nullable(),
      vector: z.string().nullable(),
    }),
    epss: z.object({
      score: z.number().min(0).max(1).nullable(),
      percentile: z.number().min(0).max(1).nullable(),
      asOf: nullableIsoDate,
    }),
    kev: z.object({
      isKnownExploited: z.boolean(),
      dateAdded: nullableIsoDate,
      dueDate: nullableIsoDate,
      notes: z.string().nullable(),
    }),
    affected: z.object({
      cpe: z.array(z.string()),
      packages: z.array(
        z.object({
          ecosystem: z.string(),
          name: z.string(),
          ranges: z.array(z.string()).optional(),
        }),
      ),
    }),
    references: z.array(
      z.object({
        url: z.string().url(),
        source: z.string(),
      }),
    ),
    sourceAttribution: z.array(
      z.object({
        source: z.string(),
        url: z.string().url().optional(),
      }),
    ),
  })
  .strict();

const baseMetaSchema = z.object({
  tookMs: z.number().int().nonnegative(),
  sourcesUsed: z.array(z.string()),
  partial: z.boolean(),
  warnings: z.array(z.string()),
});

export const searchResponseSchema = z
  .object({
    meta: baseMetaSchema.extend({
      query: z.string(),
      page: z.number().int().positive(),
      pageSize: z.number().int().positive().max(50),
    }),
    data: z.array(normalizedCveSchema),
  })
  .strict();

export const detailResponseSchema = z
  .object({
    meta: baseMetaSchema.extend({
      cveId: z.string().regex(/^CVE-\d{4}-\d{4,}$/i),
    }),
    data: normalizedCveSchema,
  })
  .strict();

export const searchQuerySchema = z
  .object({
    q: z.string().trim().max(200).default(""),
    mode: z.enum(["auto", "product", "text"]).default("auto"),
    page: z.coerce.number().int().positive().default(1),
    pageSize: z.coerce.number().int().positive().max(50).default(20),
    from: z.string().datetime({ offset: true }).optional(),
    to: z.string().datetime({ offset: true }).optional(),
    sort: z.enum(["relevance", "newest", "cvss", "epss"]).default("relevance"),
    severity: z.enum(["LOW", "MEDIUM", "HIGH", "CRITICAL", "UNKNOWN", "ALL"]).optional(),
    kev: z.enum(["ANY", "KEV_ONLY", "NOT_KEV"]).optional(),
    epssMin: z.coerce.number().min(0).max(1).optional(),
    epssMax: z.coerce.number().min(0).max(1).optional(),
    cvssMin: z.coerce.number().min(0).max(10).optional(),
    cvssMax: z.coerce.number().min(0).max(10).optional(),
  })
  .superRefine((value, ctx) => {
    if (value.from && value.to && new Date(value.from) > new Date(value.to)) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "'from' date must be before or equal to 'to' date",
        path: ["from"],
      });
    }

    if (
      value.epssMin !== undefined &&
      value.epssMax !== undefined &&
      value.epssMin > value.epssMax
    ) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "epssMin must be <= epssMax",
        path: ["epssMin"],
      });
    }

    if (
      value.cvssMin !== undefined &&
      value.cvssMax !== undefined &&
      value.cvssMin > value.cvssMax
    ) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "cvssMin must be <= cvssMax",
        path: ["cvssMin"],
      });
    }
  });

export const cveIdSchema = z.string().regex(/^CVE-\d{4}-\d{4,}$/i);

const nvdCvssSchema = z
  .object({
    cvssData: z
      .object({
        baseSeverity: z.string().optional(),
        baseScore: z.number().optional(),
        vectorString: z.string().optional(),
        version: z.string().optional(),
      })
      .passthrough()
      .optional(),
  })
  .passthrough();

const nvdNodeSchema: z.ZodType<{
  cpeMatch?: Array<{ criteria?: string; vulnerable?: boolean }>;
  nodes?: Array<unknown>;
}> = z.lazy(() =>
  z
    .object({
      cpeMatch: z
        .array(
          z
            .object({
              criteria: z.string().optional(),
              vulnerable: z.boolean().optional(),
            })
            .passthrough(),
        )
        .optional(),
      nodes: z.array(nvdNodeSchema).optional(),
    })
    .passthrough(),
);

export const nvdSearchResponseSchema = z
  .object({
    vulnerabilities: z
      .array(
        z
          .object({
            cve: z
              .object({
                id: z.string(),
                published: z.string().optional(),
                lastModified: z.string().optional(),
                descriptions: z
                  .array(
                    z
                      .object({
                        lang: z.string().optional(),
                        value: z.string().optional(),
                      })
                      .passthrough(),
                  )
                  .optional(),
                references: z
                  .array(
                    z
                      .object({
                        url: z.string().optional(),
                        source: z.string().optional(),
                      })
                      .passthrough(),
                  )
                  .optional(),
                metrics: z
                  .object({
                    cvssMetricV31: z.array(nvdCvssSchema).optional(),
                    cvssMetricV30: z.array(nvdCvssSchema).optional(),
                    cvssMetricV2: z.array(nvdCvssSchema).optional(),
                  })
                  .passthrough()
                  .optional(),
                configurations: z
                  .array(
                    z
                      .object({
                        nodes: z.array(nvdNodeSchema).optional(),
                      })
                      .passthrough(),
                  )
                  .optional(),
              })
              .passthrough(),
          })
          .passthrough(),
      )
      .default([]),
  })
  .passthrough();

const mitreCvssSchema = z
  .object({
    version: z.string().optional(),
    baseScore: z.number().optional(),
    baseSeverity: z.string().optional(),
    vectorString: z.string().optional(),
  })
  .passthrough();

const mitreMetricSchema = z
  .object({
    cvssV4_0: mitreCvssSchema.optional(),
    cvssV3_1: mitreCvssSchema.optional(),
    cvssV3_0: mitreCvssSchema.optional(),
  })
  .passthrough();

const mitreVersionSchema = z
  .object({
    status: z.string().optional(),
    version: z.string().optional(),
    lessThan: z.string().optional(),
    lessThanOrEqual: z.string().optional(),
  })
  .passthrough();

const mitreAffectedSchema = z
  .object({
    vendor: z.string().optional(),
    product: z.string().optional(),
    cpes: z.array(z.string()).optional(),
    versions: z.array(mitreVersionSchema).optional(),
  })
  .passthrough();

const mitreContainerSchema = z
  .object({
    title: z.string().optional(),
    descriptions: z
      .array(
        z
          .object({
            lang: z.string().optional(),
            value: z.string().optional(),
          })
          .passthrough(),
      )
      .optional(),
    references: z
      .array(
        z
          .object({
            url: z.string().optional(),
          })
          .passthrough(),
      )
      .optional(),
    metrics: z.array(mitreMetricSchema).optional(),
    affected: z.array(mitreAffectedSchema).optional(),
    providerMetadata: z
      .object({
        dateUpdated: z.string().optional(),
      })
      .passthrough()
      .optional(),
  })
  .passthrough();

export const mitreCveResponseSchema = z
  .object({
    cveMetadata: z
      .object({
        cveId: z.string().optional(),
        state: z.string().optional(),
        dateReserved: z.string().optional(),
        datePublished: z.string().optional(),
        dateUpdated: z.string().optional(),
      })
      .passthrough()
      .optional(),
    containers: z
      .object({
        cna: mitreContainerSchema.optional(),
        adp: z.array(mitreContainerSchema).optional(),
      })
      .passthrough()
      .optional(),
  })
  .passthrough();

export const kevCatalogResponseSchema = z
  .object({
    vulnerabilities: z
      .array(
        z
          .object({
            cveID: z.string(),
            dateAdded: z.string().optional(),
            dueDate: z.string().optional(),
            notes: z.string().optional(),
            shortDescription: z.string().optional(),
          })
          .passthrough(),
      )
      .default([]),
  })
  .passthrough();

export const epssResponseSchema = z
  .object({
    data: z
      .array(
        z
          .object({
            cve: z.string(),
            epss: z.string().optional(),
            percentile: z.string().optional(),
            date: z.string().optional(),
          })
          .passthrough(),
      )
      .default([]),
  })
  .passthrough();

export type NormalizedCveInput = z.infer<typeof normalizedCveSchema>;
export type SearchQueryInput = z.infer<typeof searchQuerySchema>;
export type SearchResponseOutput = z.infer<typeof searchResponseSchema>;
export type DetailResponseOutput = z.infer<typeof detailResponseSchema>;
