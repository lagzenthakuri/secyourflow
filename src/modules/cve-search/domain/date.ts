const NORMALIZED_DATE_SEPARATORS = /\//g;

function isValidDate(date: Date): boolean {
  return !Number.isNaN(date.getTime());
}

export function parseDateToIso(value: unknown): string | null {
  if (typeof value !== "string" || value.trim().length === 0) {
    return null;
  }

  const trimmed = value.trim();
  const dateOnlyMatch = trimmed.match(/^(\d{4})[-/](\d{2})[-/](\d{2})$/);
  if (dateOnlyMatch) {
    const year = dateOnlyMatch[1];
    const month = dateOnlyMatch[2];
    const day = dateOnlyMatch[3];
    const utcDate = new Date(Date.UTC(Number(year), Number(month) - 1, Number(day)));
    return isValidDate(utcDate) ? utcDate.toISOString() : null;
  }

  const compactMatch = trimmed.match(/^(\d{4})(\d{2})(\d{2})$/);
  if (compactMatch) {
    const year = compactMatch[1];
    const month = compactMatch[2];
    const day = compactMatch[3];
    const compactDate = new Date(Date.UTC(Number(year), Number(month) - 1, Number(day)));
    if (isValidDate(compactDate)) {
      return compactDate.toISOString();
    }
  }

  const direct = new Date(trimmed);
  if (isValidDate(direct)) {
    return direct.toISOString();
  }

  const slashNormalized = new Date(trimmed.replace(NORMALIZED_DATE_SEPARATORS, "-"));
  if (isValidDate(slashNormalized)) {
    return slashNormalized.toISOString();
  }

  return null;
}

export function toDateOrEpoch(value: string | null): number {
  if (!value) {
    return 0;
  }

  const timestamp = new Date(value).getTime();
  return Number.isNaN(timestamp) ? 0 : timestamp;
}

export function nowMs(): number {
  return Date.now();
}
