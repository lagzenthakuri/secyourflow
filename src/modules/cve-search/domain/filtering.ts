import { toDateOrEpoch } from "./date";
import { normalizeCveId } from "./normalize";
import { parseCveSearchQuery, type ParsedCveSearchQuery } from "./query-parser";
import type { NormalizedCve, SearchQuery } from "./types";

function containsText(value: string, query: string): boolean {
  return value.toLowerCase().includes(query.toLowerCase());
}

function escapeRegExp(value: string): string {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function containsWholeTerm(value: string, term: string): boolean {
  const normalizedTerm = term.trim().toLowerCase();
  if (normalizedTerm.length === 0) {
    return false;
  }

  const escaped = escapeRegExp(normalizedTerm);
  const startsAlphaNum = /^[a-z0-9]/i.test(normalizedTerm);
  const endsAlphaNum = /[a-z0-9]$/i.test(normalizedTerm);
  const prefix = startsAlphaNum ? "(^|[^a-z0-9])" : "";
  const suffix = endsAlphaNum ? "(?=$|[^a-z0-9])" : "";
  const pattern = `${prefix}${escaped}${suffix}`;

  return new RegExp(pattern, "i").test(value.toLowerCase());
}

function packageTexts(cve: NormalizedCve): string[] {
  return cve.affected.packages.map((pkg) => `${pkg.ecosystem} ${pkg.name} ${(pkg.ranges ?? []).join(" ")}`);
}

function textSearchFields(cve: NormalizedCve): string[] {
  return [
    cve.cveId,
    cve.title ?? "",
    cve.description,
    ...cve.references.map((ref) => `${ref.url} ${ref.source}`),
    ...packageTexts(cve),
    ...cve.affected.cpe,
  ];
}

function productSearchFields(cve: NormalizedCve): string[] {
  return [
    cve.title ?? "",
    cve.description,
    ...cve.references.map((ref) => `${ref.url} ${ref.source}`),
    ...packageTexts(cve),
    ...cve.affected.cpe,
  ];
}

function matchesTextQuery(cve: NormalizedCve, parsedQuery: ParsedCveSearchQuery): boolean {
  if (!parsedQuery.raw) {
    return true;
  }

  const fields = textSearchFields(cve);
  if (fields.some((field) => containsText(field, parsedQuery.raw))) {
    return true;
  }

  if (parsedQuery.includeTerms.length === 0) {
    return true;
  }

  return parsedQuery.includeTerms.every((term) =>
    fields.some((field) => containsText(field, term)),
  );
}

function matchesProductQuery(cve: NormalizedCve, parsedQuery: ParsedCveSearchQuery): boolean {
  if (parsedQuery.includeTerms.length === 0) {
    return true;
  }

  const fields = productSearchFields(cve);
  const includesAllTerms = parsedQuery.includeTerms.every((term) =>
    fields.some((field) => containsWholeTerm(field, term)),
  );

  if (!includesAllTerms) {
    return false;
  }

  if (parsedQuery.excludeTerms.length === 0) {
    return true;
  }

  return !parsedQuery.excludeTerms.some((term) =>
    fields.some((field) => containsWholeTerm(field, term)),
  );
}

function matchesParsedQuery(cve: NormalizedCve, parsedQuery: ParsedCveSearchQuery): boolean {
  if (!parsedQuery.raw) {
    return true;
  }

  if (parsedQuery.kind === "cveId") {
    const requestedId = normalizeCveId(parsedQuery.includeTerms[0] ?? parsedQuery.raw);
    return normalizeCveId(cve.cveId) === requestedId;
  }

  if (parsedQuery.kind === "product") {
    return matchesProductQuery(cve, parsedQuery);
  }

  return matchesTextQuery(cve, parsedQuery);
}

export function applySearchFilters(
  cves: NormalizedCve[],
  query: SearchQuery,
  parsedQuery: ParsedCveSearchQuery = parseCveSearchQuery(query.q, query.mode),
): NormalizedCve[] {
  const fromTs = query.from ? toDateOrEpoch(query.from) : 0;
  const toTs = query.to ? toDateOrEpoch(query.to) : Number.MAX_SAFE_INTEGER;

  return cves.filter((cve) => {
    const modifiedTs = toDateOrEpoch(cve.lastModified || cve.published);
    if (modifiedTs < fromTs || modifiedTs > toTs) {
      return false;
    }

    if (query.severity && query.severity !== "ALL" && cve.severity !== query.severity) {
      return false;
    }

    if (query.kev === "KEV_ONLY" && !cve.kev.isKnownExploited) {
      return false;
    }

    if (query.kev === "NOT_KEV" && cve.kev.isKnownExploited) {
      return false;
    }

    if (query.epssMin !== undefined && (cve.epss.score ?? -1) < query.epssMin) {
      return false;
    }

    if (query.epssMax !== undefined && (cve.epss.score ?? Number.MAX_VALUE) > query.epssMax) {
      return false;
    }

    if (query.cvssMin !== undefined && (cve.cvss.baseScore ?? -1) < query.cvssMin) {
      return false;
    }

    if (query.cvssMax !== undefined && (cve.cvss.baseScore ?? Number.MAX_VALUE) > query.cvssMax) {
      return false;
    }

    return matchesParsedQuery(cve, parsedQuery);
  });
}

export function paginate<T>(values: T[], page: number, pageSize: number): T[] {
  const start = (page - 1) * pageSize;
  return values.slice(start, start + pageSize);
}
