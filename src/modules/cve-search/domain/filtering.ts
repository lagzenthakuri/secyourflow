import { toDateOrEpoch } from "./date";
import { normalizeCveId } from "./normalize";
import { parseCveSearchQuery, type ParsedCveSearchQuery } from "./query-parser";
import type { NormalizedCve, SearchQuery } from "./types";

const REACT_COLLISION_TOKENS = new Set(["reactos", "reactor", "reactions"]);
const REACT_REFERENCE_HINTS = [
  "github.com/facebook/react",
  "npmjs.com",
  "reactjs.org",
  "react.dev",
];
const REACT_DESCRIPTION_HINT_PATTERNS = [
  /\breactdom\b/i,
  /\breact[-\s]?dom\b/i,
  /\breact native\b/i,
  /\bcreate-react-app\b/i,
  /\bjsx\b/i,
  /\breact[-\s]?dev[-\s]?utils\b/i,
  /\breact\.?js\b/i,
  /\breactjs\b/i,
];

function containsText(value: string, query: string): boolean {
  return value.toLowerCase().includes(query.toLowerCase());
}

function escapeRegExp(value: string): string {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function containsWholeTerm(value: string, term: string): boolean {
  const normalizedTerm = term.trim().toLowerCase();
  if (normalizedTerm.length === 0) {
    return false;
  }

  const escaped = escapeRegExp(normalizedTerm);
  const startsAlphaNum = /^[a-z0-9]/i.test(normalizedTerm);
  const endsAlphaNum = /[a-z0-9]$/i.test(normalizedTerm);
  const prefix = startsAlphaNum ? "(^|[^a-z0-9])" : "";
  const suffix = endsAlphaNum ? "(?=$|[^a-z0-9])" : "";
  const pattern = `${prefix}${escaped}${suffix}`;

  return new RegExp(pattern, "i").test(value.toLowerCase());
}

function packageTexts(cve: NormalizedCve): string[] {
  return cve.affected.packages.map((pkg) => `${pkg.ecosystem} ${pkg.name} ${(pkg.ranges ?? []).join(" ")}`);
}

function textSearchFields(cve: NormalizedCve): string[] {
  return [
    cve.cveId,
    cve.title ?? "",
    cve.description,
    ...cve.references.map((ref) => `${ref.url} ${ref.source}`),
    ...packageTexts(cve),
    ...cve.affected.cpe,
  ];
}

function productSearchFields(cve: NormalizedCve): string[] {
  return [
    cve.title ?? "",
    cve.description,
    ...cve.references.map((ref) => `${ref.url} ${ref.source}`),
    ...packageTexts(cve),
    ...cve.affected.cpe,
  ];
}

function hasBareReactIntent(parsedQuery: ParsedCveSearchQuery): boolean {
  if (!parsedQuery.tokens.includes("react")) {
    return false;
  }

  return !parsedQuery.tokens.some((token) => REACT_COLLISION_TOKENS.has(token));
}

function hasReactEcosystemHint(cve: NormalizedCve): boolean {
  const descriptionText = `${cve.title ?? ""} ${cve.description}`.toLowerCase();
  const referenceUrls = cve.references.map((ref) => ref.url.toLowerCase());
  const cpeValues = cve.affected.cpe.map((entry) => entry.toLowerCase());
  const packageNames = cve.affected.packages.map((pkg) => pkg.name.toLowerCase());
  const packageEcosystems = cve.affected.packages.map((pkg) => pkg.ecosystem.toLowerCase());

  const cpeHint = cpeValues.some((cpe) =>
    cpe.includes(":facebook:react:") ||
    cpe.includes(":reactjs:") ||
    cpe.includes(":react_dom:") ||
    cpe.includes(":react-dom:") ||
    cpe.includes(":react_native:") ||
    cpe.includes(":react-native:"),
  );
  if (cpeHint) {
    return true;
  }

  const packageHint = cve.affected.packages.some((pkg) => {
    const name = pkg.name.toLowerCase();
    const ecosystem = pkg.ecosystem.toLowerCase();
    return (
      name === "react" ||
      name.startsWith("react-") ||
      name.startsWith("react_") ||
      (name.startsWith("@react/") && ecosystem === "npm") ||
      (ecosystem === "npm" && name.includes("react"))
    );
  });
  if (packageHint) {
    return true;
  }

  const referenceHint = referenceUrls.some((url) =>
    REACT_REFERENCE_HINTS.some((hint) => url.includes(hint)),
  );
  if (referenceHint) {
    return true;
  }

  const descriptionHint = REACT_DESCRIPTION_HINT_PATTERNS.some((pattern) => pattern.test(descriptionText));
  if (descriptionHint) {
    return true;
  }

  const jsContextHint =
    /\breact\b/i.test(descriptionText) &&
    (/\bjavascript\b/i.test(descriptionText) ||
      /\bnode\.?js\b/i.test(descriptionText) ||
      /\bnpm\b/i.test(descriptionText) ||
      packageNames.some((name) => name.startsWith("react")) ||
      packageEcosystems.includes("npm"));

  return jsContextHint;
}

function matchesTextQuery(cve: NormalizedCve, parsedQuery: ParsedCveSearchQuery): boolean {
  if (!parsedQuery.raw) {
    return true;
  }

  const fields = textSearchFields(cve);
  if (fields.some((field) => containsText(field, parsedQuery.raw))) {
    return true;
  }

  if (parsedQuery.includeTerms.length === 0) {
    return true;
  }

  return parsedQuery.includeTerms.every((term) =>
    fields.some((field) => containsText(field, term)),
  );
}

function matchesProductQuery(cve: NormalizedCve, parsedQuery: ParsedCveSearchQuery): boolean {
  if (parsedQuery.includeTerms.length === 0) {
    return true;
  }

  const fields = productSearchFields(cve);
  const includesAllTerms = parsedQuery.includeTerms.every((term) =>
    fields.some((field) => containsWholeTerm(field, term)),
  );

  if (!includesAllTerms) {
    return false;
  }

  if (parsedQuery.excludeTerms.length === 0) {
    if (hasBareReactIntent(parsedQuery)) {
      return hasReactEcosystemHint(cve);
    }
    return true;
  }

  const hasExcludedCollision = parsedQuery.excludeTerms.some((term) =>
    fields.some((field) => containsWholeTerm(field, term)),
  );

  if (hasExcludedCollision) {
    return false;
  }

  if (hasBareReactIntent(parsedQuery)) {
    return hasReactEcosystemHint(cve);
  }

  return true;
}

function matchesParsedQuery(cve: NormalizedCve, parsedQuery: ParsedCveSearchQuery): boolean {
  if (!parsedQuery.raw) {
    return true;
  }

  if (parsedQuery.kind === "cveId") {
    const requestedId = normalizeCveId(parsedQuery.includeTerms[0] ?? parsedQuery.raw);
    return normalizeCveId(cve.cveId) === requestedId;
  }

  if (parsedQuery.kind === "product") {
    return matchesProductQuery(cve, parsedQuery);
  }

  return matchesTextQuery(cve, parsedQuery);
}

export function applySearchFilters(
  cves: NormalizedCve[],
  query: SearchQuery,
  parsedQuery: ParsedCveSearchQuery = parseCveSearchQuery(query.q, query.mode),
): NormalizedCve[] {
  const fromTs = query.from ? toDateOrEpoch(query.from) : 0;
  const toTs = query.to ? toDateOrEpoch(query.to) : Number.MAX_SAFE_INTEGER;

  return cves.filter((cve) => {
    const modifiedTs = toDateOrEpoch(cve.lastModified || cve.published);
    if (modifiedTs < fromTs || modifiedTs > toTs) {
      return false;
    }

    if (query.severity && query.severity !== "ALL" && cve.severity !== query.severity) {
      return false;
    }

    if (query.kev === "KEV_ONLY" && !cve.kev.isKnownExploited) {
      return false;
    }

    if (query.kev === "NOT_KEV" && cve.kev.isKnownExploited) {
      return false;
    }

    if (query.epssMin !== undefined && (cve.epss.score ?? -1) < query.epssMin) {
      return false;
    }

    if (query.epssMax !== undefined && (cve.epss.score ?? Number.MAX_VALUE) > query.epssMax) {
      return false;
    }

    if (query.cvssMin !== undefined && (cve.cvss.baseScore ?? -1) < query.cvssMin) {
      return false;
    }

    if (query.cvssMax !== undefined && (cve.cvss.baseScore ?? Number.MAX_VALUE) > query.cvssMax) {
      return false;
    }

    return matchesParsedQuery(cve, parsedQuery);
  });
}

export function paginate<T>(values: T[], page: number, pageSize: number): T[] {
  const start = (page - 1) * pageSize;
  return values.slice(start, start + pageSize);
}
