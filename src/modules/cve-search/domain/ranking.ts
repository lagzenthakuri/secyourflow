import { toDateOrEpoch } from "./date";
import type { NormalizedCve, SearchSort } from "./types";

function sourceConfidence(cve: NormalizedCve): number {
  const sources = new Set(cve.sourceAttribution.map((item) => item.source.toLowerCase()));
  const hasNvd = sources.has("nvd");
  const hasKev = sources.has("cisa-kev");
  const hasMitre = sources.has("mitre");

  if (hasNvd && hasMitre && hasKev) return 4;
  if (hasNvd && hasMitre) return 3;
  if (hasNvd && hasKev) return 3;
  if (hasNvd) return 2;
  if (hasMitre) return 1;
  return 0;
}

function compareRelevance(a: NormalizedCve, b: NormalizedCve): number {
  if (a.kev.isKnownExploited !== b.kev.isKnownExploited) {
    return Number(b.kev.isKnownExploited) - Number(a.kev.isKnownExploited);
  }

  const aEpss = a.epss.score ?? -1;
  const bEpss = b.epss.score ?? -1;
  if (aEpss !== bEpss) {
    return bEpss - aEpss;
  }

  const aCvss = a.cvss.baseScore ?? -1;
  const bCvss = b.cvss.baseScore ?? -1;
  if (aCvss !== bCvss) {
    return bCvss - aCvss;
  }

  const aLastModified = toDateOrEpoch(a.lastModified);
  const bLastModified = toDateOrEpoch(b.lastModified);
  if (aLastModified !== bLastModified) {
    return bLastModified - aLastModified;
  }

  const sourceDelta = sourceConfidence(b) - sourceConfidence(a);
  if (sourceDelta !== 0) {
    return sourceDelta;
  }

  return a.cveId.localeCompare(b.cveId);
}

function scoreText(value: string, query: string, tokens: string[], exactWeight: number, tokenWeight: number): number {
  const normalized = value.trim().toLowerCase();
  if (!normalized) {
    return 0;
  }

  let score = normalized.includes(query) ? exactWeight : 0;
  for (const token of tokens) {
    if (normalized.includes(token)) {
      score += tokenWeight;
    }
  }

  return score;
}

function createRelevanceComparator(queryText: string): (a: NormalizedCve, b: NormalizedCve) => number {
  const normalizedQuery = queryText.trim().toLowerCase();
  const tokens = normalizedQuery
    .split(/\s+/)
    .map((token) => token.trim())
    .filter((token) => token.length > 0);
  const scoreCache = new Map<string, number>();

  const scoreQueryMatch = (cve: NormalizedCve): number => {
    if (normalizedQuery.length === 0) {
      return 0;
    }

    const cached = scoreCache.get(cve.cveId);
    if (cached !== undefined) {
      return cached;
    }

    const cveId = cve.cveId.toLowerCase();
    if (cveId === normalizedQuery) {
      scoreCache.set(cve.cveId, 10_000);
      return 10_000;
    }

    let score = cveId.includes(normalizedQuery) ? 2_000 : 0;
    score += scoreText(cve.title ?? "", normalizedQuery, tokens, 900, 240);
    score += scoreText(cve.description, normalizedQuery, tokens, 600, 140);
    score += scoreText(cve.affected.cpe.join(" "), normalizedQuery, tokens, 240, 60);
    score += scoreText(
      cve.affected.packages.map((pkg) => `${pkg.ecosystem} ${pkg.name}`).join(" "),
      normalizedQuery,
      tokens,
      300,
      80,
    );
    score += scoreText(cve.references.map((ref) => ref.url).join(" "), normalizedQuery, tokens, 150, 50);

    scoreCache.set(cve.cveId, score);
    return score;
  };

  return (a: NormalizedCve, b: NormalizedCve) => {
    const queryDelta = scoreQueryMatch(b) - scoreQueryMatch(a);
    if (queryDelta !== 0) {
      return queryDelta;
    }

    return compareRelevance(a, b);
  };
}

export function rankCves(cves: NormalizedCve[], sort: SearchSort, queryText = ""): NormalizedCve[] {
  const copy = [...cves];
  const relevanceComparator = createRelevanceComparator(queryText);

  if (sort === "newest") {
    return copy.sort((a, b) => {
      const delta = toDateOrEpoch(b.lastModified) - toDateOrEpoch(a.lastModified);
      return delta !== 0 ? delta : relevanceComparator(a, b);
    });
  }

  if (sort === "cvss") {
    return copy.sort((a, b) => {
      const delta = (b.cvss.baseScore ?? -1) - (a.cvss.baseScore ?? -1);
      return delta !== 0 ? delta : relevanceComparator(a, b);
    });
  }

  if (sort === "epss") {
    return copy.sort((a, b) => {
      const delta = (b.epss.score ?? -1) - (a.epss.score ?? -1);
      return delta !== 0 ? delta : relevanceComparator(a, b);
    });
  }

  return copy.sort(relevanceComparator);
}
