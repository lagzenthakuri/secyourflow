import type { AffectedPackage, CveReference, NormalizedCve } from "./types";
import {
  chooseBetterSeverity,
  createBaseNormalizedCve,
  mergeAttributions,
  severityFromCvss,
} from "./normalize";
import { toDateOrEpoch } from "./date";

function uniqueStrings(values: string[]): string[] {
  return Array.from(new Set(values));
}

function uniqueReferences(values: CveReference[]): CveReference[] {
  const map = new Map<string, CveReference>();
  for (const item of values) {
    const key = `${item.url}|${item.source}`;
    map.set(key, item);
  }
  return Array.from(map.values());
}

function uniquePackages(values: AffectedPackage[]): AffectedPackage[] {
  const map = new Map<string, AffectedPackage>();
  for (const item of values) {
    const key = `${item.ecosystem}|${item.name}|${(item.ranges ?? []).join(",")}`;
    map.set(key, item);
  }
  return Array.from(map.values());
}

function preferLonger(current: string | null, next: string | null): string | null {
  if (!current) return next;
  if (!next) return current;
  return next.length > current.length ? next : current;
}

function chooseEarliestDate(current: string | null, next: string | null): string | null {
  if (!current) return next;
  if (!next) return current;
  return toDateOrEpoch(next) < toDateOrEpoch(current) ? next : current;
}

function chooseLatestDate(current: string | null, next: string | null): string | null {
  if (!current) return next;
  if (!next) return current;
  return toDateOrEpoch(next) > toDateOrEpoch(current) ? next : current;
}

function chooseHigherScore(
  current: number | null,
  next: number | null,
): number | null {
  if (current === null) return next;
  if (next === null) return current;
  return next > current ? next : current;
}

function mergeTwo(base: NormalizedCve, incoming: NormalizedCve): NormalizedCve {
  const mergedCvssScore = chooseHigherScore(base.cvss.baseScore, incoming.cvss.baseScore);

  return {
    ...base,
    title: preferLonger(base.title, incoming.title),
    description: preferLonger(base.description, incoming.description) ?? "",
    published: chooseEarliestDate(base.published, incoming.published),
    lastModified: chooseLatestDate(base.lastModified, incoming.lastModified),
    severity: chooseBetterSeverity(
      chooseBetterSeverity(base.severity, incoming.severity),
      severityFromCvss(mergedCvssScore),
    ),
    cvss: {
      version:
        (mergedCvssScore === incoming.cvss.baseScore ? incoming.cvss.version : base.cvss.version) ??
        base.cvss.version ??
        null,
      baseScore: mergedCvssScore,
      vector:
        (mergedCvssScore === incoming.cvss.baseScore ? incoming.cvss.vector : base.cvss.vector) ??
        base.cvss.vector ??
        null,
    },
    epss: {
      score: chooseHigherScore(base.epss.score, incoming.epss.score),
      percentile: chooseHigherScore(base.epss.percentile, incoming.epss.percentile),
      asOf: chooseLatestDate(base.epss.asOf, incoming.epss.asOf),
    },
    kev: {
      isKnownExploited: base.kev.isKnownExploited || incoming.kev.isKnownExploited,
      dateAdded: chooseEarliestDate(base.kev.dateAdded, incoming.kev.dateAdded),
      dueDate: chooseLatestDate(base.kev.dueDate, incoming.kev.dueDate),
      notes: preferLonger(base.kev.notes, incoming.kev.notes),
    },
    affected: {
      cpe: uniqueStrings([...base.affected.cpe, ...incoming.affected.cpe]),
      packages: uniquePackages([...base.affected.packages, ...incoming.affected.packages]),
    },
    references: uniqueReferences([...base.references, ...incoming.references]),
    sourceAttribution: mergeAttributions(base.sourceAttribution, incoming.sourceAttribution),
  };
}

export function dedupeAndMergeCves(cves: NormalizedCve[]): NormalizedCve[] {
  const byId = new Map<string, NormalizedCve>();

  for (const cve of cves) {
    const key = cve.cveId.toUpperCase();
    const current = byId.get(key) ?? createBaseNormalizedCve(key);
    byId.set(key, mergeTwo(current, cve));
  }

  return Array.from(byId.values());
}
