import { afterEach, describe, expect, it, vi } from "vitest";
import { getCveSearchConfig } from "../api/config";
import { collectSourceValues, createAbortController, elapsedMs } from "../api/helpers";
import { formatDate, formatScore, severityBadgeClass } from "../ui/presenters";

describe("config/helpers/presenters", () => {
  afterEach(() => {
    delete process.env.CVE_PER_SOURCE_TIMEOUT_MS;
  });

  it("reads config defaults and env overrides", () => {
    process.env.CVE_PER_SOURCE_TIMEOUT_MS = "100";
    const config = getCveSearchConfig();

    expect(config.timeouts.perSourceMs).toBe(100);
    expect(config.cacheTtlMs.searchResults).toBeGreaterThan(0);
  });

  it("helper functions behave deterministically", () => {
    vi.useFakeTimers();
    vi.setSystemTime(new Date("2026-02-07T00:00:00.000Z"));

    expect(elapsedMs(new Date("2026-02-06T23:59:59.000Z").getTime())).toBe(1000);

    const abort = createAbortController(5);
    expect(abort.signal.aborted).toBe(false);
    vi.advanceTimersByTime(10);
    expect(abort.signal.aborted).toBe(true);
    abort.dispose();

    vi.useRealTimers();
  });

  it("collects source values and warnings", () => {
    const warnings: string[] = [];
    const sources = new Set<string>();

    const values = collectSourceValues(
      [
        { source: "nvd", value: [], warnings: ["warn"] },
        null,
      ],
      warnings,
      sources,
    );

    expect(values).toEqual([]);
    expect(warnings.some((item) => item.includes("warn"))).toBe(true);
    expect(warnings.some((item) => item.includes("source unavailable"))).toBe(true);
    expect(sources.has("NVD")).toBe(true);
  });

  it("formats UI values", () => {
    expect(severityBadgeClass("CRITICAL")).toContain("severity-critical");
    expect(formatDate("2024-01-01T00:00:00.000Z")).toMatch(/2024|1\/1\/2024|01\/01\/2024/);
    expect(formatDate(null)).toBe("Unknown");
    expect(formatScore(0.1234, 2)).toBe("0.12");
    expect(formatScore(null)).toBe("N/A");
  });
});
