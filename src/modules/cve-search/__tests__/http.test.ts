import { describe, expect, it, vi } from "vitest";
import { computeBackoffMs, fetchJsonWithResilience, fetchWithResilience } from "../api/http";

function jsonResponse(status: number, body: unknown, headers?: HeadersInit): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      "content-type": "application/json",
      ...(headers ?? {}),
    },
  });
}

describe("api/http", () => {
  it("computes deterministic backoff", () => {
    const first = computeBackoffMs(100, 2, "https://example.com");
    const second = computeBackoffMs(100, 2, "https://example.com");
    expect(first).toBe(second);
    expect(first).toBeGreaterThanOrEqual(200);
  });

  it("retries on 500 and succeeds", async () => {
    const fetchImpl = vi
      .fn<typeof fetch>()
      .mockResolvedValueOnce(jsonResponse(500, { error: true }))
      .mockResolvedValueOnce(jsonResponse(200, { ok: true }));

    const sleep = vi.fn(async () => {});

    const response = await fetchWithResilience({
      source: "nvd",
      url: "https://example.com",
      timeoutMs: 1_000,
      maxRetries: 2,
      baseBackoffMs: 10,
      fetchImpl,
      sleepImpl: sleep,
    });

    expect(response.status).toBe(200);
    expect(fetchImpl).toHaveBeenCalledTimes(2);
    expect(sleep).toHaveBeenCalledTimes(1);
  });

  it("respects retry-after for 429", async () => {
    const fetchImpl = vi
      .fn<typeof fetch>()
      .mockResolvedValueOnce(jsonResponse(429, { error: true }, { "Retry-After": "0" }))
      .mockResolvedValueOnce(jsonResponse(200, { ok: true }));

    const sleep = vi.fn(async () => {});

    await fetchWithResilience({
      source: "mitre",
      url: "https://example.com",
      timeoutMs: 1_000,
      maxRetries: 2,
      baseBackoffMs: 10,
      fetchImpl,
      sleepImpl: sleep,
    });

    expect(fetchImpl).toHaveBeenCalledTimes(2);
    expect(sleep).toHaveBeenCalledTimes(1);
  });

  it("does not retry on 404", async () => {
    const fetchImpl = vi.fn<typeof fetch>().mockResolvedValueOnce(jsonResponse(404, { error: true }));
    const response = await fetchWithResilience({
      source: "mitre",
      url: "https://example.com",
      timeoutMs: 1_000,
      maxRetries: 2,
      baseBackoffMs: 10,
      fetchImpl,
      sleepImpl: async () => {},
    });

    expect(response.status).toBe(404);
    expect(fetchImpl).toHaveBeenCalledTimes(1);
  });

  it("throws after retries on transport errors", async () => {
    const fetchImpl = vi.fn<typeof fetch>().mockRejectedValue(new Error("socket hang up"));

    await expect(
      fetchWithResilience({
        source: "nvd",
        url: "https://example.com",
        timeoutMs: 1_000,
        maxRetries: 1,
        baseBackoffMs: 10,
        fetchImpl,
        sleepImpl: async () => {},
      }),
    ).rejects.toThrow("socket hang up");

    expect(fetchImpl).toHaveBeenCalledTimes(2);
  });

  it("fetches and parses json", async () => {
    const fetchImpl = vi.fn<typeof fetch>().mockResolvedValue(jsonResponse(200, { hello: "world" }));
    const response = await fetchJsonWithResilience<{ hello: string }>({
      source: "nvd",
      url: "https://example.com",
      timeoutMs: 1_000,
      maxRetries: 0,
      baseBackoffMs: 10,
      fetchImpl,
    });

    expect(response.status).toBe(200);
    expect(response.data.hello).toBe("world");
  });
});
