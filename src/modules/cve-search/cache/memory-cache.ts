interface CacheEntry<T> {
  value: T;
  expiresAt: number;
}

export function stableCacheKey(prefix: string, value: Record<string, unknown>): string {
  const normalized = JSON.stringify(sortObject(value));
  return `${prefix}:${normalized}`;
}

function sortObject(value: unknown): unknown {
  if (Array.isArray(value)) {
    return value.map((item) => sortObject(item));
  }

  if (value && typeof value === "object") {
    const entries = Object.entries(value as Record<string, unknown>)
      .filter(([, current]) => current !== undefined)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([key, current]) => [key, sortObject(current)]);

    return Object.fromEntries(entries);
  }

  return value;
}

export class TtlCache<T> {
  private readonly store = new Map<string, CacheEntry<T>>();

  constructor(private readonly maxEntries = 500) {}

  get(key: string, now = Date.now()): T | undefined {
    const entry = this.store.get(key);
    if (!entry) {
      return undefined;
    }

    if (entry.expiresAt <= now) {
      this.store.delete(key);
      return undefined;
    }

    this.store.delete(key);
    this.store.set(key, entry);

    return entry.value;
  }

  set(key: string, value: T, ttlMs: number, now = Date.now()): void {
    if (ttlMs <= 0) {
      return;
    }

    this.store.delete(key);
    this.store.set(key, {
      value,
      expiresAt: now + ttlMs,
    });

    this.pruneExpired(now);
    this.pruneOverflow();
  }

  clear(): void {
    this.store.clear();
  }

  size(): number {
    this.pruneExpired(Date.now());
    return this.store.size;
  }

  private pruneExpired(now: number): void {
    for (const [key, entry] of this.store.entries()) {
      if (entry.expiresAt <= now) {
        this.store.delete(key);
      }
    }
  }

  private pruneOverflow(): void {
    while (this.store.size > this.maxEntries) {
      const oldestKey = this.store.keys().next().value;
      if (!oldestKey) {
        break;
      }
      this.store.delete(oldestKey);
    }
  }
}

export class RequestCoalescer {
  private readonly inflight = new Map<string, Promise<unknown>>();

  async run<T>(key: string, factory: () => Promise<T>): Promise<T> {
    const existing = this.inflight.get(key);
    if (existing) {
      return existing as Promise<T>;
    }

    const promise = factory().finally(() => {
      this.inflight.delete(key);
    });

    this.inflight.set(key, promise);
    return promise;
  }

  size(): number {
    return this.inflight.size;
  }
}
