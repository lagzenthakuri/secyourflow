import type { AdapterContext, AdapterResult, SourceAdapter } from "./types";
import type { AdapterSearchOptions, AffectedPackage, NormalizedCve } from "../domain/types";
import { mitreCveResponseSchema } from "../domain/schemas";
import {
  createBaseNormalizedCve,
  nonEmpty,
  normalizeCveId,
  parseIsoOrNull,
  severityFromCvss,
  severityFromText,
} from "../domain/normalize";
import { fetchJsonWithResilience } from "../api/http";

interface MitreCvssMetric {
  baseScore?: number;
  baseSeverity?: string;
  vectorString?: string;
  version?: string;
}

interface MitreMetricRecord {
  cvssV4_0?: MitreCvssMetric;
  cvssV3_1?: MitreCvssMetric;
  cvssV3_0?: MitreCvssMetric;
}

interface MitreDescription {
  lang?: string;
  value?: string;
}

interface MitreReference {
  url?: string;
}

interface MitreVersion {
  version?: string;
  status?: string;
  lessThan?: string;
  lessThanOrEqual?: string;
}

interface MitreAffected {
  vendor?: string;
  product?: string;
  cpes?: string[];
  versions?: MitreVersion[];
}

interface MitreContainer {
  title?: string;
  descriptions?: MitreDescription[];
  references?: MitreReference[];
  metrics?: MitreMetricRecord[];
  affected?: MitreAffected[];
  providerMetadata?: {
    dateUpdated?: string;
  };
}

interface MitreCveRecord {
  cveMetadata?: {
    cveId?: string;
    datePublished?: string;
    dateUpdated?: string;
    dateReserved?: string;
  };
  containers?: {
    cna?: MitreContainer;
    adp?: MitreContainer[];
  };
}

function looksLikeCveId(value: string): boolean {
  return /^CVE-\d{4}-\d{4,}$/i.test(value);
}

function pickBestMetric(metrics: MitreMetricRecord[]): MitreCvssMetric | null {
  for (const metric of metrics) {
    if (metric.cvssV4_0) {
      return { version: "4.0", ...metric.cvssV4_0 };
    }

    if (metric.cvssV3_1) {
      return { version: "3.1", ...metric.cvssV3_1 };
    }

    if (metric.cvssV3_0) {
      return { version: "3.0", ...metric.cvssV3_0 };
    }
  }

  return null;
}

function formatVersionRange(value: MitreVersion): string | null {
  const parts: string[] = [];

  const status = nonEmpty(value.status);
  if (status) {
    parts.push(status);
  }

  const version = nonEmpty(value.version);
  if (version) {
    parts.push(version);
  }

  const lessThanOrEqual = nonEmpty(value.lessThanOrEqual);
  if (lessThanOrEqual) {
    parts.push(`<=${lessThanOrEqual}`);
  } else {
    const lessThan = nonEmpty(value.lessThan);
    if (lessThan) {
      parts.push(`<${lessThan}`);
    }
  }

  return parts.length > 0 ? parts.join(" ") : null;
}

function mapAffected(
  affected: MitreAffected[],
): { packages: AffectedPackage[]; cpe: string[] } {
  const packages: AffectedPackage[] = [];
  const cpe = new Set<string>();

  for (const item of affected) {
    const ecosystem = nonEmpty(item.vendor) ?? "unknown";
    const name = nonEmpty(item.product) ?? nonEmpty(item.vendor) ?? "unknown";
    const ranges = Array.isArray(item.versions)
      ? item.versions
          .map((entry) => formatVersionRange(entry))
          .filter((entry): entry is string => Boolean(entry))
      : [];

    const packageItem: AffectedPackage = {
      ecosystem,
      name,
    };

    if (ranges.length > 0) {
      packageItem.ranges = ranges;
    }

    packages.push(packageItem);

    if (Array.isArray(item.cpes)) {
      for (const entry of item.cpes) {
        if (typeof entry === "string" && entry.length > 0) {
          cpe.add(entry);
        }
      }
    }
  }

  return {
    packages,
    cpe: Array.from(cpe),
  };
}

function normalizeMitreRecord(record: MitreCveRecord, requestedCveId: string): NormalizedCve | null {
  if (!record.cveMetadata && !record.containers) {
    return null;
  }

  const cveIdValue = nonEmpty(record.cveMetadata?.cveId) ?? requestedCveId;
  if (!looksLikeCveId(cveIdValue)) {
    return null;
  }

  const cveId = normalizeCveId(cveIdValue);
  const base = createBaseNormalizedCve(cveId);
  const cna = record.containers?.cna;
  const adp = Array.isArray(record.containers?.adp) ? record.containers.adp : [];

  const descriptions = [
    ...(Array.isArray(cna?.descriptions) ? cna.descriptions : []),
    ...adp.flatMap((entry) => (Array.isArray(entry.descriptions) ? entry.descriptions : [])),
  ];
  const englishDescription = descriptions.find((entry) => entry.lang === "en")?.value;
  const fallbackDescription = descriptions.find((entry) => typeof entry.value === "string")?.value;

  const metrics = [
    ...(Array.isArray(cna?.metrics) ? cna.metrics : []),
    ...adp.flatMap((entry) => (Array.isArray(entry.metrics) ? entry.metrics : [])),
  ];
  const metric = pickBestMetric(metrics);
  const cvssScore = metric?.baseScore ?? null;
  const severity = severityFromText(metric?.baseSeverity);

  const affected = [
    ...(Array.isArray(cna?.affected) ? cna.affected : []),
    ...adp.flatMap((entry) => (Array.isArray(entry.affected) ? entry.affected : [])),
  ];
  const mappedAffected = mapAffected(affected);

  const references = new Map<string, { url: string; source: string }>();
  const referenceEntries = [
    ...(Array.isArray(cna?.references) ? cna.references : []),
    ...adp.flatMap((entry) => (Array.isArray(entry.references) ? entry.references : [])),
  ];

  for (const entry of referenceEntries) {
    if (typeof entry?.url === "string" && entry.url.length > 0) {
      references.set(entry.url, {
        url: entry.url,
        source: "MITRE",
      });
    }
  }

  const title = nonEmpty(cna?.title);
  const published = parseIsoOrNull(record.cveMetadata?.datePublished ?? record.cveMetadata?.dateReserved);
  const adpUpdatedDates = adp
    .map((entry) => parseIsoOrNull(entry.providerMetadata?.dateUpdated))
    .filter((value): value is string => Boolean(value))
    .sort((a, b) => new Date(b).getTime() - new Date(a).getTime());
  const lastModified = parseIsoOrNull(record.cveMetadata?.dateUpdated) ?? adpUpdatedDates[0] ?? null;

  return {
    ...base,
    title,
    description:
      nonEmpty(englishDescription) ??
      nonEmpty(fallbackDescription) ??
      "No description provided.",
    published,
    lastModified,
    severity: severity !== "UNKNOWN" ? severity : severityFromCvss(cvssScore),
    cvss: {
      version: nonEmpty(metric?.version) ?? null,
      baseScore: cvssScore,
      vector: nonEmpty(metric?.vectorString) ?? null,
    },
    affected: mappedAffected,
    references: Array.from(references.values()),
    sourceAttribution: [
      {
        source: "MITRE",
        url: `https://www.cve.org/CVERecord?id=${cveId}`,
      },
    ],
  };
}

export class MitreAdapter implements SourceAdapter {
  readonly source = "MITRE";

  constructor(private readonly context: AdapterContext) {}

  async search(query: string, options: AdapterSearchOptions): Promise<AdapterResult> {
    const normalizedQuery = query.trim();

    if (!looksLikeCveId(normalizedQuery)) {
      return {
        cves: [],
        warnings: [],
      };
    }

    const result = await this.getById(normalizedQuery, options.signal);
    return {
      cves: result.cve ? [result.cve] : [],
      warnings: result.warnings,
    };
  }

  async getById(
    cveId: string,
    signal?: AbortSignal,
  ): Promise<{ cve: NormalizedCve | null; warnings: string[] }> {
    const normalizedId = normalizeCveId(cveId);
    const baseUrl = this.context.config.mitreApiBaseUrl.replace(/\/+$/, "");
    const url = `${baseUrl}/${encodeURIComponent(normalizedId)}`;

    const response = await fetchJsonWithResilience<unknown>({
      source: "mitre",
      url,
      timeoutMs: this.context.config.timeouts.perSourceMs,
      maxRetries: this.context.config.retries.maxRetries,
      baseBackoffMs: this.context.config.retries.baseBackoffMs,
      signal,
      fetchImpl: this.context.fetchImpl,
      init: {
        headers: {
          Accept: "application/json",
        },
      },
    });

    if (response.status === 404) {
      return {
        cve: null,
        warnings: [],
      };
    }

    if (response.status === 429) {
      return {
        cve: null,
        warnings: ["MITRE CVE API rate limited"],
      };
    }

    if (response.status >= 500) {
      return {
        cve: null,
        warnings: [`MITRE CVE API upstream error (${response.status})`],
      };
    }

    if (response.status >= 400) {
      return {
        cve: null,
        warnings: [`MITRE CVE API request failed (${response.status})`],
      };
    }

    const parsed = mitreCveResponseSchema.safeParse(response.data);
    if (!parsed.success) {
      return {
        cve: null,
        warnings: ["MITRE CVE API response validation failed"],
      };
    }

    const normalized = normalizeMitreRecord(parsed.data, normalizedId);
    if (!normalized) {
      return {
        cve: null,
        warnings: ["MITRE CVE API response validation failed"],
      };
    }

    return {
      cve: normalized,
      warnings: [],
    };
  }
}
