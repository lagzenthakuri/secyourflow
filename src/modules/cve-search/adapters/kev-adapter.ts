import type { AdapterContext } from "./types";
import { fetchJsonWithResilience } from "../api/http";
import { kevCatalogResponseSchema } from "../domain/schemas";
import { normalizeCveId, parseIsoOrNull } from "../domain/normalize";

export interface KevEntry {
  cveId: string;
  dateAdded: string | null;
  dueDate: string | null;
  notes: string | null;
}

export class KevAdapter {
  readonly source = "CISA-KEV";

  constructor(private readonly context: AdapterContext) {}

  async getCatalog(signal?: AbortSignal): Promise<{ entries: KevEntry[]; warnings: string[] }> {
    const response = await fetchJsonWithResilience<unknown>({
      source: "cisa_kev",
      url: this.context.config.cisaKevUrl,
      timeoutMs: this.context.config.timeouts.perSourceMs,
      maxRetries: this.context.config.retries.maxRetries,
      baseBackoffMs: this.context.config.retries.baseBackoffMs,
      signal,
      fetchImpl: this.context.fetchImpl,
      init: {
        headers: {
          Accept: "application/json",
        },
      },
    });

    if (response.status >= 400) {
      throw new Error(`KEV catalog fetch failed with status ${response.status}`);
    }

    const parsed = kevCatalogResponseSchema.safeParse(response.data);
    if (!parsed.success) {
      return {
        entries: [],
        warnings: ["KEV response validation failed"],
      };
    }

    const entries = parsed.data.vulnerabilities
      .filter((item) => /^CVE-\d{4}-\d{4,}$/i.test(item.cveID))
      .map((item) => ({
        cveId: normalizeCveId(item.cveID),
        dateAdded: parseIsoOrNull(item.dateAdded),
        dueDate: parseIsoOrNull(item.dueDate),
        notes: item.notes ?? item.shortDescription ?? null,
      }));

    return {
      entries,
      warnings: [],
    };
  }

  async getByCveIds(
    cveIds: string[],
    signal?: AbortSignal,
  ): Promise<{ byId: Map<string, KevEntry>; warnings: string[] }> {
    const result = await this.getCatalog(signal);
    const idSet = new Set(cveIds.map((value) => normalizeCveId(value)));

    const byId = new Map<string, KevEntry>();
    for (const entry of result.entries) {
      if (idSet.has(entry.cveId)) {
        byId.set(entry.cveId, entry);
      }
    }

    return {
      byId,
      warnings: result.warnings,
    };
  }

  async getById(
    cveId: string,
    signal?: AbortSignal,
  ): Promise<{ entry: KevEntry | null; warnings: string[] }> {
    const result = await this.getByCveIds([cveId], signal);

    return {
      entry: result.byId.get(normalizeCveId(cveId)) ?? null,
      warnings: result.warnings,
    };
  }
}
