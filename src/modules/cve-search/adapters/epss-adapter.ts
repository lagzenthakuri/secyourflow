import type { AdapterContext } from "./types";
import { fetchJsonWithResilience } from "../api/http";
import { epssResponseSchema } from "../domain/schemas";
import { normalizeCveId, parseIsoOrNull } from "../domain/normalize";

export interface EpssEntry {
  cveId: string;
  score: number | null;
  percentile: number | null;
  asOf: string | null;
}

function parseNumber(value: string | undefined): number | null {
  if (!value) {
    return null;
  }

  const parsed = Number(value);
  if (!Number.isFinite(parsed)) {
    return null;
  }

  return parsed;
}

export class EpssAdapter {
  readonly source = "EPSS";

  constructor(private readonly context: AdapterContext) {}

  async getScores(
    cveIds: string[],
    signal?: AbortSignal,
  ): Promise<{ byId: Map<string, EpssEntry>; warnings: string[] }> {
    const normalizedIds = Array.from(
      new Set(
        cveIds
          .map((value) => normalizeCveId(value))
          .filter((value) => /^CVE-\d{4}-\d{4,}$/i.test(value)),
      ),
    );

    if (normalizedIds.length === 0) {
      return {
        byId: new Map<string, EpssEntry>(),
        warnings: [],
      };
    }

    const chunks: string[][] = [];
    for (let index = 0; index < normalizedIds.length; index += 50) {
      chunks.push(normalizedIds.slice(index, index + 50));
    }

    const byId = new Map<string, EpssEntry>();
    const warnings: string[] = [];

    for (const chunk of chunks) {
      const params = new URLSearchParams();
      params.set("cve", chunk.join(","));

      const url = `${this.context.config.epssApiBaseUrl}?${params.toString()}`;

      const response = await fetchJsonWithResilience<unknown>({
        source: "epss",
        url,
        timeoutMs: this.context.config.timeouts.perSourceMs,
        maxRetries: this.context.config.retries.maxRetries,
        baseBackoffMs: this.context.config.retries.baseBackoffMs,
        signal,
        fetchImpl: this.context.fetchImpl,
        init: {
          headers: {
            Accept: "application/json",
          },
        },
      });

      if (response.status >= 400) {
        throw new Error(`EPSS fetch failed with status ${response.status}`);
      }

      const parsed = epssResponseSchema.safeParse(response.data);
      if (!parsed.success) {
        warnings.push("EPSS response validation failed");
        continue;
      }

      for (const entry of parsed.data.data) {
        const normalizedId = normalizeCveId(entry.cve);
        byId.set(normalizedId, {
          cveId: normalizedId,
          score: parseNumber(entry.epss),
          percentile: parseNumber(entry.percentile),
          asOf: parseIsoOrNull(entry.date),
        });
      }
    }

    return {
      byId,
      warnings,
    };
  }

  async getById(
    cveId: string,
    signal?: AbortSignal,
  ): Promise<{ entry: EpssEntry | null; warnings: string[] }> {
    const result = await this.getScores([cveId], signal);

    return {
      entry: result.byId.get(normalizeCveId(cveId)) ?? null,
      warnings: result.warnings,
    };
  }
}
