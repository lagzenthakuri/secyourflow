import type { AdapterContext, AdapterResult, SourceAdapter } from "./types";
import type { AdapterSearchOptions, NormalizedCve, Severity } from "../domain/types";
import { nvdSearchResponseSchema } from "../domain/schemas";
import {
  createBaseNormalizedCve,
  nonEmpty,
  normalizeCveId,
  parseIsoOrNull,
  severityFromCvss,
  severityFromText,
} from "../domain/normalize";
import { fetchJsonWithResilience } from "../api/http";
import { logEvent } from "../api/log";

interface NvdMetric {
  cvssData?: {
    baseScore?: number;
    baseSeverity?: string;
    vectorString?: string;
    version?: string;
  };
}

interface NvdDescription {
  lang?: string;
  value?: string;
}

interface NvdReference {
  url?: string;
  source?: string;
}

interface NvdConfiguration {
  nodes?: unknown[];
}

interface NvdCveRecord {
  id?: string;
  published?: string;
  lastModified?: string;
  descriptions?: NvdDescription[];
  references?: NvdReference[];
  metrics?: {
    cvssMetricV31?: NvdMetric[];
    cvssMetricV30?: NvdMetric[];
    cvssMetricV2?: NvdMetric[];
  };
  configurations?: NvdConfiguration[];
}

function extractCpe(nodes: unknown[]): string[] {
  const values = new Set<string>();

  const walk = (currentNodes: unknown[]): void => {
    for (const node of currentNodes) {
      if (!node || typeof node !== "object") {
        continue;
      }

      const current = node as {
        cpeMatch?: Array<{ criteria?: string; vulnerable?: boolean }>;
        nodes?: unknown[];
      };

      for (const cpe of current.cpeMatch ?? []) {
        if (cpe.vulnerable !== false && cpe.criteria) {
          values.add(cpe.criteria);
        }
      }

      if (Array.isArray(current.nodes)) {
        walk(current.nodes);
      }
    }
  };

  walk(nodes);
  return Array.from(values);
}

function pickPrimaryMetric(metrics: {
  cvssMetricV31?: NvdMetric[];
  cvssMetricV30?: NvdMetric[];
  cvssMetricV2?: NvdMetric[];
}): NvdMetric | null {
  return (
    metrics.cvssMetricV31?.[0] ??
    metrics.cvssMetricV30?.[0] ??
    metrics.cvssMetricV2?.[0] ??
    null
  );
}

function normalizeNvdItem(item: unknown): NormalizedCve | null {
  if (!item || typeof item !== "object") {
    return null;
  }

  const wrapper = item as { cve?: NvdCveRecord };
  if (!wrapper.cve?.id) {
    return null;
  }

  const cveId = normalizeCveId(wrapper.cve.id);
  const base = createBaseNormalizedCve(cveId);
  const descriptions = Array.isArray(wrapper.cve.descriptions) ? wrapper.cve.descriptions : [];
  const englishDescription = descriptions.find((entry) => entry.lang === "en")?.value;

  const metric = pickPrimaryMetric(wrapper.cve.metrics ?? {});
  const cvssScore = metric?.cvssData?.baseScore ?? null;
  const severityFromMetric = severityFromText(metric?.cvssData?.baseSeverity) as Severity;

  const references = Array.isArray(wrapper.cve.references)
    ? wrapper.cve.references
        .filter((ref): ref is NvdReference & { url: string } => typeof ref?.url === "string")
        .map((ref) => ({
          url: ref.url,
          source: nonEmpty(ref.source) ?? "NVD",
        }))
    : [];

  return {
    ...base,
    description: nonEmpty(englishDescription) ?? "No description provided.",
    published: parseIsoOrNull(wrapper.cve.published),
    lastModified: parseIsoOrNull(wrapper.cve.lastModified),
    severity:
      severityFromMetric !== "UNKNOWN"
        ? severityFromMetric
        : severityFromCvss(cvssScore),
    cvss: {
      version: metric?.cvssData?.version ?? null,
      baseScore: cvssScore,
      vector: metric?.cvssData?.vectorString ?? null,
    },
    affected: {
      cpe: extractCpe(
        Array.isArray(wrapper.cve.configurations)
          ? wrapper.cve.configurations.flatMap((entry: { nodes?: unknown[] }) => entry.nodes ?? [])
          : [],
      ),
      packages: [],
    },
    references,
    sourceAttribution: [
      {
        source: "NVD",
        url: `https://nvd.nist.gov/vuln/detail/${cveId}`,
      },
    ],
  };
}

export class NvdAdapter implements SourceAdapter {
  readonly source = "NVD";

  constructor(private readonly context: AdapterContext) {}

  async search(query: string, options: AdapterSearchOptions): Promise<AdapterResult> {
    const params = new URLSearchParams();
    const normalizedQuery = query.trim();
    const requestedCveId = /^CVE-\d{4}-\d{4,}$/i.test(normalizedQuery)
      ? normalizeCveId(normalizedQuery)
      : null;

    if (requestedCveId) {
      params.set("cveId", requestedCveId);
    } else if (normalizedQuery) {
      params.set("keywordSearch", normalizedQuery);
    }

    params.set("startIndex", String((options.page - 1) * options.pageSize));
    params.set("resultsPerPage", String(options.pageSize));

    if (options.from) {
      params.set("pubStartDate", options.from);
    }

    if (options.to) {
      params.set("pubEndDate", options.to);
    }

    const url = `${this.context.config.nvdApiBaseUrl}?${params.toString()}`;
    if (process.env.NODE_ENV !== "production" && process.env.CVE_SEARCH_DEBUG === "true") {
      logEvent("info", "nvd_request_url", { url });
    }

    const response = await fetchJsonWithResilience<unknown>({
      source: this.source.toLowerCase(),
      url,
      timeoutMs: this.context.config.timeouts.perSourceMs,
      maxRetries: this.context.config.retries.maxRetries,
      baseBackoffMs: this.context.config.retries.baseBackoffMs,
      signal: options.signal,
      fetchImpl: this.context.fetchImpl,
      init: {
        headers: {
          Accept: "application/json",
        },
      },
    });

    if (response.status >= 400) {
      throw new Error(`NVD search failed with status ${response.status}`);
    }

    const parsed = nvdSearchResponseSchema.safeParse(response.data);
    if (!parsed.success) {
      return {
        cves: [],
        warnings: ["NVD response validation failed"],
      };
    }

    const normalized = parsed.data.vulnerabilities
      .map((item) => normalizeNvdItem(item))
      .filter((entry): entry is NormalizedCve => Boolean(entry));

    const cves = requestedCveId
      ? normalized.filter((entry) => entry.cveId === requestedCveId)
      : normalized;

    return {
      cves,
      warnings: [],
    };
  }

  async getById(
    cveId: string,
    signal?: AbortSignal,
  ): Promise<{ cve: NormalizedCve | null; warnings: string[] }> {
    const result = await this.search(normalizeCveId(cveId), {
      page: 1,
      pageSize: 1,
      signal,
    });

    const normalizedId = normalizeCveId(cveId);
    const cve = result.cves.find((item) => item.cveId === normalizedId) ?? null;

    return {
      cve,
      warnings: result.warnings,
    };
  }
}
