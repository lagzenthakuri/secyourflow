import type { AttackMappingSource } from "@prisma/client";
import { lookupTechniquesByCwe } from "./cwe-technique-map";
import { ThreatIntelRepository } from "../persistence/repository";

const TECHNIQUE_PATTERN = /\bT\d{4}(?:\.\d{3})?\b/gi;

interface VulnerabilityRecord {
  id: string;
  cveId: string | null;
  title: string;
  description: string | null;
  cweId: string | null;
  references: string[];
}

function extractTechniqueIds(value: string): string[] {
  const matches = value.match(TECHNIQUE_PATTERN);
  if (!matches) {
    return [];
  }

  return [...new Set(matches.map((match) => match.toUpperCase()))];
}

function collectDirectTechniqueMatches(vulnerability: VulnerabilityRecord): string[] {
  const candidates = [
    vulnerability.title,
    vulnerability.description ?? "",
    ...vulnerability.references,
  ];

  const collected = new Set<string>();

  for (const candidate of candidates) {
    for (const techniqueId of extractTechniqueIds(candidate)) {
      collected.add(techniqueId);
    }
  }

  return [...collected];
}

export interface VulnerabilityMappingSummary {
  direct: number;
  cwe: number;
  errors: string[];
}

export class VulnerabilityTechniqueMapper {
  constructor(private readonly repository: ThreatIntelRepository) {}

  async mapOrganizationVulnerabilities(organizationId: string): Promise<VulnerabilityMappingSummary> {
    const vulnerabilities = (await this.repository.listOrgVulnerabilities(organizationId)) as VulnerabilityRecord[];
    let direct = 0;
    let cwe = 0;
    const errors: string[] = [];

    for (const vulnerability of vulnerabilities) {
      const directTechniques = collectDirectTechniqueMatches(vulnerability);
      for (const techniqueExternalId of directTechniques) {
        try {
          const result = await this.repository.upsertVulnerabilityTechniqueMapping({
            vulnerabilityId: vulnerability.id,
            techniqueExternalId,
            mappingSource: "CVE_REFERENCE",
            confidence: 90,
            notes: "Detected technique identifier in vulnerability text/reference",
          });
          if (result) {
            direct += 1;
          }
        } catch (error) {
          errors.push(
            `Failed direct mapping for ${vulnerability.id}:${techniqueExternalId} - ${
              error instanceof Error ? error.message : String(error)
            }`,
          );
        }
      }

      const cweTechniques = lookupTechniquesByCwe(vulnerability.cweId);
      for (const techniqueExternalId of cweTechniques) {
        try {
          const result = await this.repository.upsertVulnerabilityTechniqueMapping({
            vulnerabilityId: vulnerability.id,
            techniqueExternalId,
            mappingSource: "CWE_MAPPING",
            confidence: 70,
            notes: `Mapped from CWE ${vulnerability.cweId ?? "UNKNOWN"}`,
          });
          if (result) {
            cwe += 1;
          }
        } catch (error) {
          errors.push(
            `Failed CWE mapping for ${vulnerability.id}:${techniqueExternalId} - ${
              error instanceof Error ? error.message : String(error)
            }`,
          );
        }
      }
    }

    return { direct, cwe, errors };
  }

  async linkVulnerabilitiesToActors(organizationId: string): Promise<{ linked: number; errors: string[] }> {
    const mappings = await this.repository.listVulnerabilityTechniqueMappings(organizationId);
    const actorTechniqueLinks = await this.repository.listActorTechniqueLinks();

    const techniqueToActorIds = new Map<string, string[]>();
    for (const link of actorTechniqueLinks) {
      const existing = techniqueToActorIds.get(link.techniqueId) ?? [];
      if (!existing.includes(link.actorId)) {
        existing.push(link.actorId);
      }
      techniqueToActorIds.set(link.techniqueId, existing);
    }

    let linked = 0;
    const errors: string[] = [];

    for (const mapping of mappings) {
      const actorIds = techniqueToActorIds.get(mapping.techniqueId) ?? [];
      for (const actorId of actorIds) {
        try {
          await this.repository.upsertVulnerabilityActorLink({
            vulnerabilityId: mapping.vulnerabilityId,
            actorId,
            source: "TECHNIQUE_INFERENCE" satisfies AttackMappingSource,
            notes: `Linked through ATT&CK technique ${mapping.technique.externalId}`,
          });
          linked += 1;
        } catch (error) {
          errors.push(
            `Failed actor link for vulnerability ${mapping.vulnerabilityId} and actor ${actorId}: ${
              error instanceof Error ? error.message : String(error)
            }`,
          );
        }
      }
    }

    return { linked, errors };
  }
}
