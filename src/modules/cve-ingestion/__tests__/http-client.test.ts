import { describe, it, expect, vi, beforeEach } from "vitest";
import { TokenBucketRateLimiter, HttpClient, normalizeUrl } from "../utils/http-client";

describe("TokenBucketRateLimiter", () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  it("should allow requests up to the limit", async () => {
    const limiter = new TokenBucketRateLimiter(5); // 5 per 30s

    const promises = [
      limiter.acquire(),
      limiter.acquire(),
      limiter.acquire(),
      limiter.acquire(),
      limiter.acquire(),
    ];

    await Promise.all(promises);
    expect(true).toBe(true); // All should complete immediately
  });

  it("should queue requests beyond the limit", async () => {
    const limiter = new TokenBucketRateLimiter(2); // 2 per 30s

    const start = Date.now();
    
    await limiter.acquire();
    await limiter.acquire();
    
    const thirdPromise = limiter.acquire();
    
    // Should be queued
    expect(thirdPromise).toBeInstanceOf(Promise);
    
    // Advance time to allow refill
    vi.advanceTimersByTime(15000); // 15s = 1 token
    
    await thirdPromise;
    
    expect(true).toBe(true);
  });
});

describe("normalizeUrl", () => {
  it("should lowercase scheme and host", () => {
    const result = normalizeUrl("HTTPS://EXAMPLE.COM/Path");
    expect(result).toBe("https://example.com/Path");
  });

  it("should remove default ports", () => {
    expect(normalizeUrl("http://example.com:80/path")).toBe("http://example.com/path");
    expect(normalizeUrl("https://example.com:443/path")).toBe("https://example.com/path");
  });

  it("should preserve non-default ports", () => {
    expect(normalizeUrl("https://example.com:8443/path")).toBe("https://example.com:8443/path");
  });

  it("should remove tracking parameters", () => {
    const url = "https://example.com/path?utm_source=test&utm_medium=email&fbclid=123&keep=this";
    const result = normalizeUrl(url);
    
    expect(result).not.toContain("utm_");
    expect(result).not.toContain("fbclid");
    expect(result).toContain("keep=this");
  });

  it("should handle invalid URLs gracefully", () => {
    const invalid = "not-a-url";
    expect(normalizeUrl(invalid)).toBe(invalid);
  });
});

describe("HttpClient", () => {
  it("should retry on 429 status", async () => {
    let attempts = 0;
    
    const mockFetch = vi.fn(async () => {
      attempts++;
      if (attempts < 3) {
        return new Response(null, { status: 429 });
      }
      return new Response(JSON.stringify({ success: true }), { status: 200 });
    });

    global.fetch = mockFetch;

    const client = new HttpClient({
      retryConfig: {
        maxRetries: 3,
        baseBackoffMs: 10,
        maxBackoffMs: 100,
        retryableStatuses: [429],
      },
      timeoutMs: 5000,
    });

    const result = await client.fetch("https://example.com/api");
    
    expect(attempts).toBe(3);
    expect(result.status).toBe(200);
    expect(result.data).toEqual({ success: true });
  });

  it("should fail after max retries", async () => {
    const mockFetch = vi.fn(async () => new Response(null, { status: 503 }));
    global.fetch = mockFetch;

    const client = new HttpClient({
      retryConfig: {
        maxRetries: 2,
        baseBackoffMs: 10,
        maxBackoffMs: 100,
        retryableStatuses: [503],
      },
    });

    await expect(client.fetch("https://example.com/api")).rejects.toThrow();
    expect(mockFetch).toHaveBeenCalledTimes(3); // Initial + 2 retries
  });
});
