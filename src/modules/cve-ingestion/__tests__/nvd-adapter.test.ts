import { describe, it, expect, vi } from "vitest";
import { NvdIngestionAdapter } from "../adapters/nvd-ingestion-adapter";
import { getIngestionConfig } from "../config";
import { HttpClient } from "../utils/http-client";

describe("NvdIngestionAdapter", () => {
  it("should handle pagination correctly", async () => {
    const config = getIngestionConfig();
    
    let callCount = 0;
    const mockFetch = vi.fn(async (url: string) => {
      callCount++;
      const urlObj = new URL(url);
      const startIndex = parseInt(urlObj.searchParams.get("startIndex") || "0");

      if (startIndex === 0) {
        return {
          data: {
            resultsPerPage: 2000,
            startIndex: 0,
            totalResults: 3500,
            timestamp: new Date().toISOString(),
            vulnerabilities: Array(2000).fill(null).map((_, i) => ({
              cve: {
                id: `CVE-2024-${String(i).padStart(5, "0")}`,
                published: "2024-01-01T00:00:00.000",
                lastModified: "2024-01-01T00:00:00.000",
                vulnStatus: "PUBLISHED",
                descriptions: [{ lang: "en", value: "Test vulnerability" }],
              },
            })),
          },
          status: 200,
          headers: new Headers(),
        };
      } else {
        return {
          data: {
            resultsPerPage: 2000,
            startIndex: 2000,
            totalResults: 3500,
            timestamp: new Date().toISOString(),
            vulnerabilities: Array(1500).fill(null).map((_, i) => ({
              cve: {
                id: `CVE-2024-${String(i + 2000).padStart(5, "0")}`,
                published: "2024-01-01T00:00:00.000",
                lastModified: "2024-01-01T00:00:00.000",
                vulnStatus: "PUBLISHED",
                descriptions: [{ lang: "en", value: "Test vulnerability" }],
              },
            })),
          },
          status: 200,
          headers: new Headers(),
        };
      }
    });

    const httpClient = { fetch: mockFetch } as unknown as HttpClient;
    const adapter = new NvdIngestionAdapter(config, httpClient);

    const checkpoint = {
      source: "NVD",
      cursor: null,
      windowStart: null,
      windowEnd: null,
      lastSuccessAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 7 days ago
      recordsProcessed: 0,
      status: "idle" as const,
      errorMessage: null,
    };

    const result = await adapter.fetchIncremental(checkpoint);

    expect(callCount).toBe(2); // Two pages
    expect(result.records).toHaveLength(3500);
  });

  it("should enforce minimum interval", async () => {
    const config = getIngestionConfig();
    const httpClient = { fetch: vi.fn() } as unknown as HttpClient;
    const adapter = new NvdIngestionAdapter(config, httpClient);

    const checkpoint = {
      source: "NVD",
      cursor: null,
      windowStart: null,
      windowEnd: null,
      lastSuccessAt: new Date(Date.now() - 1 * 60 * 60 * 1000), // 1 hour ago
      recordsProcessed: 0,
      status: "idle" as const,
      errorMessage: null,
    };

    const result = await adapter.fetchIncremental(checkpoint);

    expect(result.records).toHaveLength(0);
    expect(httpClient.fetch).not.toHaveBeenCalled();
  });

  it("should handle REJECTED CVEs", async () => {
    const config = getIngestionConfig();
    
    const mockFetch = vi.fn(async () => ({
      data: {
        resultsPerPage: 1,
        startIndex: 0,
        totalResults: 1,
        timestamp: new Date().toISOString(),
        vulnerabilities: [{
          cve: {
            id: "CVE-2024-00001",
            published: "2024-01-01T00:00:00.000",
            lastModified: "2024-01-02T00:00:00.000",
            vulnStatus: "REJECTED",
            descriptions: [{ lang: "en", value: "** REJECT **" }],
          },
        }],
      },
      status: 200,
      headers: new Headers(),
    }));

    const httpClient = { fetch: mockFetch } as unknown as HttpClient;
    const adapter = new NvdIngestionAdapter(config, httpClient);

    const checkpoint = {
      source: "NVD",
      cursor: null,
      windowStart: null,
      windowEnd: null,
      lastSuccessAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
      recordsProcessed: 0,
      status: "idle" as const,
      errorMessage: null,
    };

    const result = await adapter.fetchIncremental(checkpoint);

    expect(result.records).toHaveLength(1);
    expect(result.records[0].state).toBe("REJECTED");
  });

  it("should extract KEV fields from NVD", async () => {
    const config = getIngestionConfig();
    
    const mockFetch = vi.fn(async () => ({
      data: {
        resultsPerPage: 1,
        startIndex: 0,
        totalResults: 1,
        timestamp: new Date().toISOString(),
        vulnerabilities: [{
          cve: {
            id: "CVE-2024-00001",
            published: "2024-01-01T00:00:00.000",
            lastModified: "2024-01-02T00:00:00.000",
            vulnStatus: "PUBLISHED",
            descriptions: [{ lang: "en", value: "Test" }],
            cisaExploitAdd: "2024-01-15",
            cisaActionDue: "2024-02-15",
            cisaRequiredAction: "Apply patches",
            cisaVulnerabilityName: "Test Vulnerability",
          },
        }],
      },
      status: 200,
      headers: new Headers(),
    }));

    const httpClient = { fetch: mockFetch } as unknown as HttpClient;
    const adapter = new NvdIngestionAdapter(config, httpClient);

    const checkpoint = {
      source: "NVD",
      cursor: null,
      windowStart: null,
      windowEnd: null,
      lastSuccessAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
      recordsProcessed: 0,
      status: "idle" as const,
      errorMessage: null,
    };

    const result = await adapter.fetchIncremental(checkpoint);

    expect(result.records[0].kev.flag).toBe(true);
    expect(result.records[0].kev.dateAdded).toBeInstanceOf(Date);
    expect(result.records[0].kev.requiredAction).toBe("Apply patches");
  });
});
