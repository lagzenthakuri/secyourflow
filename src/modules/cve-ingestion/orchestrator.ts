import { PrismaClient } from "@prisma/client";
import { getIngestionConfig } from "./config";
import type { IngestionResult, IngestionHealthStatus } from "./types";
import { HttpClient, TokenBucketRateLimiter } from "./utils/http-client";
import { logger } from "./utils/logger";
import { NvdIngestionAdapter } from "./adapters/nvd-ingestion-adapter";
import { KevIngestionAdapter } from "./adapters/kev-ingestion-adapter";
import { EpssIngestionAdapter } from "./adapters/epss-ingestion-adapter";
import { CveRepository } from "./persistence/repository";

export class IngestionOrchestrator {
  private readonly config = getIngestionConfig();
  private readonly prisma: PrismaClient;
  private readonly repository: CveRepository;
  private readonly nvdClient: HttpClient;
  private readonly kevClient: HttpClient;
  private readonly epssClient: HttpClient;

  constructor(prisma?: PrismaClient) {
    this.prisma = prisma || new PrismaClient();
    this.repository = new CveRepository(this.prisma);

    // NVD client with strict rate limiting
    const nvdRateLimiter = new TokenBucketRateLimiter(this.config.nvd.rateLimit.requestsPer30Seconds);
    this.nvdClient = new HttpClient({
      rateLimiter: nvdRateLimiter,
      timeoutMs: 30000,
      retryConfig: {
        maxRetries: 3,
        baseBackoffMs: 2000,
        maxBackoffMs: 60000,
        retryableStatuses: [429, 500, 502, 503, 504],
      },
    });

    // KEV and EPSS clients with more lenient limits
    this.kevClient = new HttpClient({ timeoutMs: 15000 });
    this.epssClient = new HttpClient({ timeoutMs: 15000 });
  }

  async ingestNvd(): Promise<IngestionResult> {
    const startTime = Date.now();
    const source = "NVD";

    logger.info("Starting NVD ingestion");

    try {
      const checkpoint = (await this.repository.getCheckpoint(source)) || {
        source,
        cursor: null,
        windowStart: null,
        windowEnd: null,
        lastSuccessAt: null,
        recordsProcessed: 0,
        status: "idle" as const,
        errorMessage: null,
      };

      await this.repository.saveCheckpoint({ ...checkpoint, status: "running" });

      const adapter = new NvdIngestionAdapter(this.config, this.nvdClient);
      const { records, newCheckpoint } = await adapter.fetchIncremental(checkpoint);

      let created = 0;
      let updated = 0;
      let skipped = 0;
      const errors: string[] = [];

      for (const record of records) {
        try {
          const result = await this.repository.upsertCve(record);
          if (result.created) created++;
          else if (result.updated) updated++;
          else skipped++;
        } catch (error) {
          errors.push(`${record.cveId}: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      await this.repository.saveCheckpoint(newCheckpoint);

      const durationMs = Date.now() - startTime;

      logger.info("NVD ingestion completed", {
        recordsFetched: records.length,
        created,
        updated,
        skipped,
        errors: errors.length,
        durationMs,
      });

      return {
        source,
        success: true,
        recordsFetched: records.length,
        recordsCreated: created,
        recordsUpdated: updated,
        recordsSkipped: skipped,
        errors,
        warnings: [],
        durationMs,
        checkpoint: newCheckpoint,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("NVD ingestion failed", { error: errorMessage });

      const checkpoint = await this.repository.getCheckpoint(source);
      if (checkpoint) {
        await this.repository.saveCheckpoint({
          ...checkpoint,
          status: "error",
          errorMessage,
        });
      }

      return {
        source,
        success: false,
        recordsFetched: 0,
        recordsCreated: 0,
        recordsUpdated: 0,
        recordsSkipped: 0,
        errors: [errorMessage],
        warnings: [],
        durationMs: Date.now() - startTime,
        checkpoint: checkpoint || {
          source,
          cursor: null,
          windowStart: null,
          windowEnd: null,
          lastSuccessAt: null,
          recordsProcessed: 0,
          status: "error",
          errorMessage,
        },
      };
    }
  }

  async enrichWithKev(): Promise<IngestionResult> {
    const startTime = Date.now();
    const source = "KEV";

    logger.info("Starting KEV enrichment");

    try {
      const adapter = new KevIngestionAdapter(this.config, this.kevClient);
      const kevMap = await adapter.fetchCatalog();

      const count = await this.repository.enrichWithKev(kevMap);

      const checkpoint = {
        source,
        cursor: null,
        windowStart: null,
        windowEnd: null,
        lastSuccessAt: new Date(),
        recordsProcessed: count,
        status: "idle" as const,
        errorMessage: null,
      };

      await this.repository.saveCheckpoint(checkpoint);

      const durationMs = Date.now() - startTime;

      logger.info("KEV enrichment completed", { count, durationMs });

      return {
        source,
        success: true,
        recordsFetched: kevMap.size,
        recordsCreated: 0,
        recordsUpdated: count,
        recordsSkipped: 0,
        errors: [],
        warnings: [],
        durationMs,
        checkpoint,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("KEV enrichment failed", { error: errorMessage });

      return {
        source,
        success: false,
        recordsFetched: 0,
        recordsCreated: 0,
        recordsUpdated: 0,
        recordsSkipped: 0,
        errors: [errorMessage],
        warnings: [],
        durationMs: Date.now() - startTime,
        checkpoint: {
          source,
          cursor: null,
          windowStart: null,
          windowEnd: null,
          lastSuccessAt: null,
          recordsProcessed: 0,
          status: "error",
          errorMessage,
        },
      };
    }
  }

  async enrichWithEpss(cveIds?: string[]): Promise<IngestionResult> {
    const startTime = Date.now();
    const source = "EPSS";

    logger.info("Starting EPSS enrichment");

    try {
      // If no CVE IDs provided, fetch recent CVEs from DB
      if (!cveIds) {
        const recentCves = await this.prisma.cve.findMany({
          where: {
            status: "ACTIVE",
            publishedAt: {
              gte: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000), // Last year
            },
          },
          select: { cveId: true },
          take: 10000,
        });
        cveIds = recentCves.map((c) => c.cveId);
      }

      const adapter = new EpssIngestionAdapter(this.config, this.epssClient);
      const epssMap = await adapter.fetchScores(cveIds);

      const count = await this.repository.enrichWithEpss(epssMap);

      const checkpoint = {
        source,
        cursor: null,
        windowStart: null,
        windowEnd: null,
        lastSuccessAt: new Date(),
        recordsProcessed: count,
        status: "idle" as const,
        errorMessage: null,
      };

      await this.repository.saveCheckpoint(checkpoint);

      const durationMs = Date.now() - startTime;

      logger.info("EPSS enrichment completed", { count, durationMs });

      return {
        source,
        success: true,
        recordsFetched: epssMap.size,
        recordsCreated: 0,
        recordsUpdated: count,
        recordsSkipped: 0,
        errors: [],
        warnings: [],
        durationMs,
        checkpoint,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error("EPSS enrichment failed", { error: errorMessage });

      return {
        source,
        success: false,
        recordsFetched: 0,
        recordsCreated: 0,
        recordsUpdated: 0,
        recordsSkipped: 0,
        errors: [errorMessage],
        warnings: [],
        durationMs: Date.now() - startTime,
        checkpoint: {
          source,
          cursor: null,
          windowStart: null,
          windowEnd: null,
          lastSuccessAt: null,
          recordsProcessed: 0,
          status: "error",
          errorMessage,
        },
      };
    }
  }

  async runFullIngestion(): Promise<IngestionResult[]> {
    logger.info("Starting full ingestion pipeline");

    const results: IngestionResult[] = [];

    // 1. Ingest from NVD
    results.push(await this.ingestNvd());

    // 2. Enrich with KEV
    results.push(await this.enrichWithKev());

    // 3. Enrich with EPSS
    results.push(await this.enrichWithEpss());

    logger.info("Full ingestion pipeline completed", {
      totalRecordsCreated: results.reduce((sum, r) => sum + r.recordsCreated, 0),
      totalRecordsUpdated: results.reduce((sum, r) => sum + r.recordsUpdated, 0),
      totalErrors: results.reduce((sum, r) => sum + r.errors.length, 0),
    });

    return results;
  }

  async getHealth(): Promise<IngestionHealthStatus> {
    const sources = ["NVD", "KEV", "EPSS"];
    const statuses = await Promise.all(
      sources.map(async (source) => {
        const checkpoint = await this.repository.getCheckpoint(source);

        if (!checkpoint) {
          return {
            name: source,
            lastSuccessAt: null,
            lastAttemptAt: null,
            status: "down" as const,
            errorMessage: "Never run",
            recordsProcessed: 0,
          };
        }

        const hoursSinceSuccess = checkpoint.lastSuccessAt
          ? (Date.now() - checkpoint.lastSuccessAt.getTime()) / (1000 * 60 * 60)
          : Infinity;

        let status: "healthy" | "degraded" | "down";
        if (checkpoint.status === "error") {
          status = "down";
        } else if (hoursSinceSuccess > 24) {
          status = "degraded";
        } else {
          status = "healthy";
        }

        return {
          name: source,
          lastSuccessAt: checkpoint.lastSuccessAt,
          lastAttemptAt: checkpoint.lastSuccessAt,
          status,
          errorMessage: checkpoint.errorMessage,
          recordsProcessed: checkpoint.recordsProcessed,
        };
      })
    );

    const overallStatus = statuses.some((s) => s.status === "down")
      ? "down"
      : statuses.some((s) => s.status === "degraded")
      ? "degraded"
      : "healthy";

    return {
      sources: statuses,
      overallStatus,
    };
  }
}
