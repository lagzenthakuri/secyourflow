import { PrismaClient, Prisma } from "@prisma/client";
import type { NormalizedCveDocument, IngestionCheckpoint } from "../types";
import { deduplicateReferences } from "../utils/url-deduper";
import { logger } from "../utils/logger";

export class CveRepository {
  constructor(private readonly prisma: PrismaClient) {}

  async upsertCve(doc: NormalizedCveDocument): Promise<{ created: boolean; updated: boolean }> {
    // Deduplicate references
    const dedupedRefs = deduplicateReferences(
      doc.references.map((r) => ({
        url: r.url,
        source: r.sources[0] || "UNKNOWN",
        tags: r.tags,
      }))
    );

    const existing = await this.prisma.cve.findUnique({
      where: { cveId: doc.cveId },
      select: { id: true, lastModifiedAt: true },
    });

    const isNewer = !existing || doc.lastModified > existing.lastModifiedAt;

    if (!isNewer) {
      return { created: false, updated: false };
    }

    const severity = this.mapSeverity(doc.metrics.best?.severity || "UNKNOWN");
    const status = this.mapStatus(doc.state);

    const cveData = {
      cveId: doc.cveId,
      description: doc.descriptions.find((d) => d.lang === "en")?.value || doc.descriptions[0]?.value || "",
      publishedAt: doc.published || new Date(),
      lastModifiedAt: doc.lastModified,
      severity,
      cweIds: doc.weakness.map((w) => w.cweId),
      status,
      isKev: doc.kev.flag,
      epssScore: doc.epss.score,
      epssPercentile: doc.epss.percentile,
      updatedAt: new Date(),
    };

    if (existing) {
      await this.prisma.cve.update({
        where: { cveId: doc.cveId },
        data: cveData,
      });

      // Update related records
      await this.updateRelatedRecords(doc.cveId, doc, dedupedRefs);

      return { created: false, updated: true };
    } else {
      await this.prisma.cve.create({
        data: {
          id: doc.cveId,
          ...cveData,
        },
      });

      // Create related records
      await this.createRelatedRecords(doc.cveId, doc, dedupedRefs);

      return { created: true, updated: false };
    }
  }

  private async createRelatedRecords(
    cveId: string,
    doc: NormalizedCveDocument,
    dedupedRefs: ReturnType<typeof deduplicateReferences>
  ) {
    // Create CVSS records
    for (const metric of doc.metrics.allRaw) {
      await this.prisma.cveCvss.create({
        data: {
          id: `${cveId}-${metric.version}-${metric.source}`,
          cveId,
          version: metric.version,
          vectorString: metric.vector,
          baseScore: metric.baseScore,
          baseSeverity: metric.severity,
        },
      });
    }

    // Create CPE records
    for (const cpe of doc.affected.cpe) {
      await this.prisma.cveCpe.create({
        data: {
          id: `${cveId}-${cpe.uri}`,
          cveId,
          cpeUri: cpe.uri,
          vendor: cpe.vendor,
          product: cpe.product,
          version: cpe.version,
          versionStartIncluding: cpe.versionStartIncluding,
          versionEndExcluding: cpe.versionEndExcluding,
          vulnerable: cpe.vulnerable,
        },
      });
    }

    // Create reference records
    for (const ref of dedupedRefs) {
      await this.prisma.cveReference.create({
        data: {
          id: `${cveId}-${ref.normalizedUrl}`,
          cveId,
          url: ref.url,
          source: ref.sources.join(","),
          tags: ref.tags,
        },
      });
    }

    // Create provenance records
    for (const source of doc.sources) {
      await this.prisma.cveProvenance.create({
        data: {
          id: `${cveId}-${source.sourceName}-${source.fetchedAt.getTime()}`,
          cveId,
          source: source.sourceName,
          field: "full",
          lastUpdated: source.fetchedAt,
          checksum: source.rawJsonHash,
        },
      });
    }

    // Create KEV record if applicable
    if (doc.kev.flag && doc.kev.dateAdded && doc.kev.dueDate) {
      await this.prisma.kevEntry.upsert({
        where: { cveId },
        create: {
          id: cveId,
          cveId,
          vulnerabilityName: doc.kev.vulnerabilityName || "",
          dateAdded: doc.kev.dateAdded,
          dueDate: doc.kev.dueDate,
          requiredAction: doc.kev.requiredAction || "",
          notes: doc.kev.notes,
        },
        update: {
          vulnerabilityName: doc.kev.vulnerabilityName || "",
          dateAdded: doc.kev.dateAdded,
          dueDate: doc.kev.dueDate,
          requiredAction: doc.kev.requiredAction || "",
          notes: doc.kev.notes,
        },
      });
    }
  }

  private async updateRelatedRecords(
    cveId: string,
    doc: NormalizedCveDocument,
    dedupedRefs: ReturnType<typeof deduplicateReferences>
  ) {
    // Delete and recreate related records for simplicity
    await this.prisma.cveCvss.deleteMany({ where: { cveId } });
    await this.prisma.cveCpe.deleteMany({ where: { cveId } });
    await this.prisma.cveReference.deleteMany({ where: { cveId } });

    await this.createRelatedRecords(cveId, doc, dedupedRefs);
  }

  async getCheckpoint(source: string): Promise<IngestionCheckpoint | null> {
    const state = await this.prisma.ingestionState.findUnique({
      where: { source },
    });

    if (!state) return null;

    return {
      source: state.source,
      cursor: null,
      windowStart: null,
      windowEnd: null,
      lastSuccessAt: state.lastSuccessAt,
      recordsProcessed: state.recordsProcessed,
      status: state.status as "idle" | "running" | "error",
      errorMessage: state.errorMessage,
    };
  }

  async saveCheckpoint(checkpoint: IngestionCheckpoint): Promise<void> {
    await this.prisma.ingestionState.upsert({
      where: { source: checkpoint.source },
      create: {
        id: checkpoint.source,
        source: checkpoint.source,
        lastSyncAt: new Date(),
        lastSuccessAt: checkpoint.lastSuccessAt,
        status: checkpoint.status,
        errorMessage: checkpoint.errorMessage,
        recordsProcessed: checkpoint.recordsProcessed,
      },
      update: {
        lastSyncAt: new Date(),
        lastSuccessAt: checkpoint.lastSuccessAt,
        status: checkpoint.status,
        errorMessage: checkpoint.errorMessage,
        recordsProcessed: checkpoint.recordsProcessed,
      },
    });
  }

  async enrichWithKev(kevMap: Map<string, any>): Promise<number> {
    let count = 0;

    for (const [cveId, kev] of kevMap.entries()) {
      const existing = await this.prisma.cve.findUnique({
        where: { cveId },
        select: { id: true },
      });

      if (!existing) continue;

      await this.prisma.cve.update({
        where: { cveId },
        data: { isKev: true },
      });

      await this.prisma.kevEntry.upsert({
        where: { cveId },
        create: {
          id: cveId,
          cveId,
          vulnerabilityName: kev.vulnerabilityName || "",
          dateAdded: kev.dateAdded,
          dueDate: kev.dueDate,
          requiredAction: kev.requiredAction || "",
          notes: kev.notes,
        },
        update: {
          vulnerabilityName: kev.vulnerabilityName || "",
          dateAdded: kev.dateAdded,
          dueDate: kev.dueDate,
          requiredAction: kev.requiredAction || "",
          notes: kev.notes,
        },
      });

      count++;
    }

    return count;
  }

  async enrichWithEpss(epssMap: Map<string, any>): Promise<number> {
    let count = 0;

    for (const [cveId, epss] of epssMap.entries()) {
      const existing = await this.prisma.cve.findUnique({
        where: { cveId },
        select: { id: true },
      });

      if (!existing) continue;

      await this.prisma.cve.update({
        where: { cveId },
        data: {
          epssScore: epss.score,
          epssPercentile: epss.percentile,
        },
      });

      count++;
    }

    return count;
  }

  private mapSeverity(severity: string): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "INFORMATIONAL" {
    switch (severity.toUpperCase()) {
      case "CRITICAL":
        return "CRITICAL";
      case "HIGH":
        return "HIGH";
      case "MEDIUM":
        return "MEDIUM";
      case "LOW":
        return "LOW";
      default:
        return "INFORMATIONAL";
    }
  }

  private mapStatus(state: string): "ACTIVE" | "REJECTED" | "RESERVED" {
    switch (state) {
      case "PUBLISHED":
        return "ACTIVE";
      case "REJECTED":
        return "REJECTED";
      case "RESERVED":
        return "RESERVED";
      default:
        return "ACTIVE";
    }
  }
}
