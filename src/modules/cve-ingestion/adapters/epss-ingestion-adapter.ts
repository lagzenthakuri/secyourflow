import type { IngestionConfig } from "../config";
import { HttpClient } from "../utils/http-client";
import { logger } from "../utils/logger";

interface EpssResponse {
  status: string;
  "status-code": number;
  version: string;
  access: string;
  total: number;
  offset: number;
  limit: number;
  data: Array<{
    cve: string;
    epss: string;
    percentile: string;
    date: string;
  }>;
}

export interface EpssEnrichment {
  cveId: string;
  score: number | null;
  percentile: number | null;
  date: Date | null;
}

export class EpssIngestionAdapter {
  private readonly config: IngestionConfig;
  private readonly httpClient: HttpClient;

  constructor(config: IngestionConfig, httpClient: HttpClient) {
    this.config = config;
    this.httpClient = httpClient;
  }

  async fetchScores(cveIds: string[]): Promise<Map<string, EpssEnrichment>> {
    const enrichments = new Map<string, EpssEnrichment>();

    // Chunk CVEs to stay under URL length limit
    const chunks = this.chunkCveIds(cveIds);

    logger.info("Fetching EPSS scores", { totalCves: cveIds.length, chunks: chunks.length });

    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      const url = `${this.config.epss.baseUrl}?cve=${chunk.join(",")}`;

      try {
        const response = await this.httpClient.fetch<EpssResponse>(url);

        for (const item of response.data.data) {
          const cveId = item.cve.toUpperCase();
          enrichments.set(cveId, {
            cveId,
            score: this.parseFloat(item.epss),
            percentile: this.parseFloat(item.percentile),
            date: this.parseDate(item.date),
          });
        }

        logger.debug("EPSS chunk fetched", { chunk: i + 1, total: chunks.length, count: response.data.data.length });
      } catch (error) {
        logger.error("Failed to fetch EPSS chunk", {
          chunk: i + 1,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }

    logger.info("EPSS scores fetched", { count: enrichments.size });

    return enrichments;
  }

  private chunkCveIds(cveIds: string[]): string[][] {
    const chunks: string[][] = [];
    let currentChunk: string[] = [];
    let currentLength = 0;

    for (const cveId of cveIds) {
      const itemLength = cveId.length + 1; // +1 for comma

      if (currentChunk.length >= this.config.epss.rateLimit.maxCvesPerRequest || currentLength + itemLength > 2000) {
        if (currentChunk.length > 0) {
          chunks.push(currentChunk);
        }
        currentChunk = [cveId];
        currentLength = cveId.length;
      } else {
        currentChunk.push(cveId);
        currentLength += itemLength;
      }
    }

    if (currentChunk.length > 0) {
      chunks.push(currentChunk);
    }

    return chunks;
  }

  private parseFloat(value: string): number | null {
    const parsed = parseFloat(value);
    return isNaN(parsed) ? null : parsed;
  }

  private parseDate(dateStr: string): Date | null {
    try {
      return new Date(dateStr);
    } catch {
      return null;
    }
  }
}
