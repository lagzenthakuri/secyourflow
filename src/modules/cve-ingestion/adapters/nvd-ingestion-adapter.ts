import type { IngestionConfig } from "../config";
import type { NormalizedCveDocument, CveState, IngestionCheckpoint } from "../types";
import { HttpClient, hashJson } from "../utils/http-client";
import { logger } from "../utils/logger";

interface NvdCveResponse {
  resultsPerPage: number;
  startIndex: number;
  totalResults: number;
  format: string;
  version: string;
  timestamp: string;
  vulnerabilities: Array<{
    cve: {
      id: string;
      sourceIdentifier?: string;
      published?: string;
      lastModified?: string;
      vulnStatus?: string;
      descriptions?: Array<{ lang: string; value: string }>;
      metrics?: {
        cvssMetricV40?: Array<{
          cvssData: {
            version: string;
            vectorString: string;
            baseScore: number;
            baseSeverity: string;
          };
          source?: string;
        }>;
        cvssMetricV31?: Array<{
          cvssData: {
            version: string;
            vectorString: string;
            baseScore: number;
            baseSeverity: string;
          };
          source?: string;
        }>;
        cvssMetricV30?: Array<{
          cvssData: {
            version: string;
            vectorString: string;
            baseScore: number;
            baseSeverity: string;
          };
          source?: string;
        }>;
        cvssMetricV2?: Array<{
          cvssData: {
            version: string;
            vectorString: string;
            baseScore: number;
            baseSeverity?: string;
          };
          source?: string;
        }>;
      };
      weaknesses?: Array<{
        source?: string;
        type?: string;
        description: Array<{ lang: string; value: string }>;
      }>;
      configurations?: Array<{
        nodes: Array<{
          operator?: string;
          negate?: boolean;
          cpeMatch?: Array<{
            vulnerable: boolean;
            criteria: string;
            versionStartIncluding?: string;
            versionEndExcluding?: string;
            matchCriteriaId?: string;
          }>;
        }>;
      }>;
      references?: Array<{
        url: string;
        source?: string;
        tags?: string[];
      }>;
      // KEV fields from NVD
      cisaExploitAdd?: string;
      cisaActionDue?: string;
      cisaRequiredAction?: string;
      cisaVulnerabilityName?: string;
    };
  }>;
}

export class NvdIngestionAdapter {
  private readonly config: IngestionConfig;
  private readonly httpClient: HttpClient;

  constructor(config: IngestionConfig, httpClient: HttpClient) {
    this.config = config;
    this.httpClient = httpClient;
  }

  async fetchIncremental(
    checkpoint: IngestionCheckpoint
  ): Promise<{ records: NormalizedCveDocument[]; newCheckpoint: IngestionCheckpoint }> {
    const now = new Date();
    const lastSuccess = checkpoint.lastSuccessAt;

    // Enforce minimum interval
    if (lastSuccess) {
      const hoursSinceLastSync = (now.getTime() - lastSuccess.getTime()) / (1000 * 60 * 60);
      if (hoursSinceLastSync < this.config.nvd.minIntervalHours) {
        logger.info("Skipping NVD sync: minimum interval not reached", {
          hoursSinceLastSync,
          minHours: this.config.nvd.minIntervalHours,
        });
        return { records: [], newCheckpoint: checkpoint };
      }
    }

    const windowStart = lastSuccess || new Date(Date.now() - 120 * 24 * 60 * 60 * 1000); // 120 days default
    const windowEnd = now;

    // Enforce max window
    const windowDays = (windowEnd.getTime() - windowStart.getTime()) / (1000 * 60 * 60 * 24);
    if (windowDays > this.config.nvd.pagination.maxWindowDays) {
      logger.warn("Window exceeds max days, truncating", {
        windowDays,
        maxDays: this.config.nvd.pagination.maxWindowDays,
      });
      windowStart.setTime(windowEnd.getTime() - this.config.nvd.pagination.maxWindowDays * 24 * 60 * 60 * 1000);
    }

    const records: NormalizedCveDocument[] = [];
    let startIndex = 0;
    let totalResults = 0;

    do {
      const url = this.buildUrl({
        startIndex,
        resultsPerPage: this.config.nvd.pagination.resultsPerPage,
        lastModStartDate: windowStart.toISOString(),
        lastModEndDate: windowEnd.toISOString(),
      });

      logger.info("Fetching NVD page", { startIndex, resultsPerPage: this.config.nvd.pagination.resultsPerPage });

      const response = await this.httpClient.fetch<NvdCveResponse>(url);
      totalResults = response.data.totalResults;

      for (const vuln of response.data.vulnerabilities) {
        try {
          const normalized = this.normalizeNvdCve(vuln.cve, response.data.timestamp);
          records.push(normalized);
        } catch (error) {
          logger.error("Failed to normalize NVD CVE", {
            cveId: vuln.cve.id,
            error: error instanceof Error ? error.message : String(error),
          });
        }
      }

      startIndex += this.config.nvd.pagination.resultsPerPage;
    } while (startIndex < totalResults);

    const newCheckpoint: IngestionCheckpoint = {
      source: "NVD",
      cursor: null,
      windowStart: windowStart.toISOString(),
      windowEnd: windowEnd.toISOString(),
      lastSuccessAt: now,
      recordsProcessed: checkpoint.recordsProcessed + records.length,
      status: "idle",
      errorMessage: null,
    };

    return { records, newCheckpoint };
  }

  private buildUrl(params: {
    startIndex: number;
    resultsPerPage: number;
    lastModStartDate?: string;
    lastModEndDate?: string;
  }): string {
    const url = new URL(this.config.nvd.baseUrl);
    url.searchParams.set("startIndex", params.startIndex.toString());
    url.searchParams.set("resultsPerPage", params.resultsPerPage.toString());

    if (params.lastModStartDate) {
      url.searchParams.set("lastModStartDate", params.lastModStartDate);
    }
    if (params.lastModEndDate) {
      url.searchParams.set("lastModEndDate", params.lastModEndDate);
    }

    if (this.config.nvd.apiKey) {
      url.searchParams.set("apiKey", this.config.nvd.apiKey);
    }

    return url.toString();
  }

  private normalizeNvdCve(cve: NvdCveResponse["vulnerabilities"][0]["cve"], fetchTimestamp: string): NormalizedCveDocument {
    const cveId = cve.id;
    const state = this.mapVulnStatus(cve.vulnStatus);
    const published = cve.published ? new Date(cve.published) : null;
    const lastModified = new Date(cve.lastModified || fetchTimestamp);

    const descriptions = (cve.descriptions || []).map((d) => ({
      lang: d.lang,
      value: d.value,
    }));

    const references = (cve.references || []).map((r) => ({
      url: r.url,
      normalizedUrl: r.url, // Will be normalized by deduper
      sources: [r.source || "NVD"],
      tags: r.tags || [],
    }));

    const metrics = this.extractMetrics(cve.metrics);
    const weakness = this.extractWeakness(cve.weaknesses);
    const affected = this.extractAffected(cve.configurations);
    const kev = this.extractKev(cve);

    const rawJson = JSON.stringify(cve);
    const rawJsonHash = hashJson(cve);

    return {
      cveId,
      state,
      published,
      lastModified,
      descriptions,
      references,
      affected,
      metrics,
      weakness,
      kev,
      epss: {
        score: null,
        percentile: null,
        date: null,
      },
      sources: [
        {
          sourceName: "NVD",
          fetchedAt: new Date(fetchTimestamp),
          sourceVersion: null,
          url: `https://nvd.nist.gov/vuln/detail/${cveId}`,
          rawJsonHash,
          rawJson: rawJson.length <= this.config.storage.rawPayloadSizeLimit ? rawJson : null,
        },
      ],
    };
  }

  private mapVulnStatus(status: string | undefined): CveState {
    switch (status?.toUpperCase()) {
      case "PUBLISHED":
      case "ANALYZED":
      case "MODIFIED":
        return "PUBLISHED";
      case "REJECTED":
        return "REJECTED";
      case "RESERVED":
        return "RESERVED";
      default:
        return "UNKNOWN";
    }
  }

  private extractMetrics(metrics: NvdCveResponse["vulnerabilities"][0]["cve"]["metrics"]) {
    const allRaw: NormalizedCveDocument["metrics"]["allRaw"] = [];

    if (metrics?.cvssMetricV40) {
      for (const m of metrics.cvssMetricV40) {
        allRaw.push({
          version: "4.0",
          baseScore: m.cvssData.baseScore,
          severity: m.cvssData.baseSeverity,
          vector: m.cvssData.vectorString,
          source: m.source || "NVD",
        });
      }
    }

    if (metrics?.cvssMetricV31) {
      for (const m of metrics.cvssMetricV31) {
        allRaw.push({
          version: "3.1",
          baseScore: m.cvssData.baseScore,
          severity: m.cvssData.baseSeverity,
          vector: m.cvssData.vectorString,
          source: m.source || "NVD",
        });
      }
    }

    if (metrics?.cvssMetricV30) {
      for (const m of metrics.cvssMetricV30) {
        allRaw.push({
          version: "3.0",
          baseScore: m.cvssData.baseScore,
          severity: m.cvssData.baseSeverity,
          vector: m.cvssData.vectorString,
          source: m.source || "NVD",
        });
      }
    }

    if (metrics?.cvssMetricV2) {
      for (const m of metrics.cvssMetricV2) {
        allRaw.push({
          version: "2.0",
          baseScore: m.cvssData.baseScore,
          severity: m.cvssData.baseSeverity || "UNKNOWN",
          vector: m.cvssData.vectorString,
          source: m.source || "NVD",
        });
      }
    }

    // Best metric: v4 > v3.1 > v3.0 > v2
    const best = allRaw.sort((a, b) => {
      const versionOrder = { "4.0": 4, "3.1": 3, "3.0": 2, "2.0": 1 };
      return (versionOrder[b.version as keyof typeof versionOrder] || 0) - (versionOrder[a.version as keyof typeof versionOrder] || 0);
    })[0] || null;

    return { best, allRaw };
  }

  private extractWeakness(weaknesses: NvdCveResponse["vulnerabilities"][0]["cve"]["weaknesses"]) {
    const result: NormalizedCveDocument["weakness"] = [];

    for (const w of weaknesses || []) {
      for (const desc of w.description) {
        if (desc.value.startsWith("CWE-")) {
          result.push({
            cweId: desc.value,
            description: null,
          });
        }
      }
    }

    return result;
  }

  private extractAffected(configurations: NvdCveResponse["vulnerabilities"][0]["cve"]["configurations"]) {
    const cpe: NormalizedCveDocument["affected"]["cpe"] = [];

    for (const config of configurations || []) {
      for (const node of config.nodes) {
        for (const match of node.cpeMatch || []) {
          const parsed = this.parseCpe(match.criteria);
          if (parsed) {
            cpe.push({
              uri: match.criteria,
              vendor: parsed.vendor,
              product: parsed.product,
              version: parsed.version,
              versionStartIncluding: match.versionStartIncluding || null,
              versionEndExcluding: match.versionEndExcluding || null,
              vulnerable: match.vulnerable,
            });
          }
        }
      }
    }

    return { cpe, packages: [] };
  }

  private parseCpe(cpeUri: string): { vendor: string; product: string; version: string } | null {
    // cpe:2.3:a:vendor:product:version:...
    const parts = cpeUri.split(":");
    if (parts.length < 6) return null;

    return {
      vendor: parts[3] || "*",
      product: parts[4] || "*",
      version: parts[5] || "*",
    };
  }

  private extractKev(cve: NvdCveResponse["vulnerabilities"][0]["cve"]): NormalizedCveDocument["kev"] {
    return {
      flag: !!cve.cisaExploitAdd,
      dateAdded: cve.cisaExploitAdd ? new Date(cve.cisaExploitAdd) : null,
      dueDate: cve.cisaActionDue ? new Date(cve.cisaActionDue) : null,
      requiredAction: cve.cisaRequiredAction || null,
      vulnerabilityName: cve.cisaVulnerabilityName || null,
      notes: null,
      ransomwareUse: null,
    };
  }
}
