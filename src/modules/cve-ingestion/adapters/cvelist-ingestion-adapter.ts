import type { IngestionConfig } from "../config";
import type { NormalizedCveDocument, CveState } from "../types";
import { HttpClient, hashJson } from "../utils/http-client";
import { logger } from "../utils/logger";

interface CveListV5 {
  dataType: string;
  dataVersion: string;
  cveMetadata: {
    cveId: string;
    assignerOrgId?: string;
    state?: string;
    datePublished?: string;
    dateUpdated?: string;
    dateReserved?: string;
  };
  containers: {
    cna?: CveContainer;
    adp?: CveContainer[];
  };
}

interface CveContainer {
  providerMetadata?: {
    orgId?: string;
    shortName?: string;
    dateUpdated?: string;
  };
  title?: string;
  descriptions?: Array<{
    lang: string;
    value: string;
  }>;
  affected?: Array<{
    vendor?: string;
    product?: string;
    versions?: Array<{
      version: string;
      status?: string;
      lessThan?: string;
      lessThanOrEqual?: string;
    }>;
    cpes?: string[];
  }>;
  metrics?: Array<{
    format?: string;
    cvssV4_0?: CvssMetric;
    cvssV3_1?: CvssMetric;
    cvssV3_0?: CvssMetric;
    cvssV2_0?: CvssMetric;
  }>;
  references?: Array<{
    url: string;
    name?: string;
    tags?: string[];
  }>;
  problemTypes?: Array<{
    descriptions: Array<{
      lang?: string;
      description: string;
      cweId?: string;
    }>;
  }>;
}

interface CvssMetric {
  version: string;
  vectorString: string;
  baseScore: number;
  baseSeverity?: string;
}

export class CveListIngestionAdapter {
  private readonly config: IngestionConfig;
  private readonly httpClient: HttpClient;

  constructor(config: IngestionConfig, httpClient: HttpClient) {
    this.config = config;
    this.httpClient = httpClient;
  }

  async fetchFromGitHubRelease(): Promise<NormalizedCveDocument[]> {
    logger.info("Fetching CVE List from GitHub releases");

    // For now, we'll implement a simplified version that fetches individual CVEs
    // A full implementation would download the release assets (baseline + deltas)
    logger.warn("CVE List full ingestion not yet implemented - use NVD as primary source");

    return [];
  }

  normalizeCveListRecord(record: CveListV5): NormalizedCveDocument {
    const cveId = record.cveMetadata.cveId;
    const state = this.mapState(record.cveMetadata.state);
    const published = record.cveMetadata.datePublished ? new Date(record.cveMetadata.datePublished) : null;
    const lastModified = new Date(record.cveMetadata.dateUpdated || record.cveMetadata.datePublished || Date.now());

    // Merge CNA + ADP containers
    const containers: CveContainer[] = [];
    if (record.containers.cna) {
      containers.push(record.containers.cna);
    }
    if (record.containers.adp) {
      containers.push(...record.containers.adp);
    }

    const descriptions = this.mergeDescriptions(containers);
    const references = this.mergeReferences(containers);
    const metrics = this.mergeMetrics(containers);
    const weakness = this.mergeWeakness(containers);
    const affected = this.mergeAffected(containers);
    const kev = this.extractKevFromAdp(containers);

    const rawJson = JSON.stringify(record);
    const rawJsonHash = hashJson(record);

    return {
      cveId,
      state,
      published,
      lastModified,
      descriptions,
      references,
      affected,
      metrics,
      weakness,
      kev,
      epss: {
        score: null,
        percentile: null,
        date: null,
      },
      sources: [
        {
          sourceName: "CVE-List",
          fetchedAt: new Date(),
          sourceVersion: record.dataVersion,
          url: `https://github.com/CVEProject/cvelistV5/tree/main/cves/${cveId.slice(4, 8)}/${cveId.slice(9, 12)}xxx/${cveId}.json`,
          rawJsonHash,
          rawJson: rawJson.length <= this.config.storage.rawPayloadSizeLimit ? rawJson : null,
        },
      ],
    };
  }

  private mapState(state: string | undefined): CveState {
    switch (state?.toUpperCase()) {
      case "PUBLISHED":
        return "PUBLISHED";
      case "REJECTED":
        return "REJECTED";
      case "RESERVED":
        return "RESERVED";
      default:
        return "UNKNOWN";
    }
  }

  private mergeDescriptions(containers: CveContainer[]) {
    const byLang = new Map<string, string>();

    for (const container of containers) {
      for (const desc of container.descriptions || []) {
        if (!byLang.has(desc.lang)) {
          byLang.set(desc.lang, desc.value);
        }
      }
    }

    return Array.from(byLang.entries()).map(([lang, value]) => ({ lang, value }));
  }

  private mergeReferences(containers: CveContainer[]) {
    const refs: Array<{ url: string; normalizedUrl: string; sources: string[]; tags: string[] }> = [];

    for (const container of containers) {
      const source = container.providerMetadata?.shortName || "CVE-List";
      for (const ref of container.references || []) {
        refs.push({
          url: ref.url,
          normalizedUrl: ref.url,
          sources: [source],
          tags: ref.tags || [],
        });
      }
    }

    return refs;
  }

  private mergeMetrics(containers: CveContainer[]) {
    const allRaw: NormalizedCveDocument["metrics"]["allRaw"] = [];

    for (const container of containers) {
      const source = container.providerMetadata?.shortName || "CVE-List";
      
      for (const metric of container.metrics || []) {
        if (metric.cvssV4_0) {
          allRaw.push({
            version: "4.0",
            baseScore: metric.cvssV4_0.baseScore,
            severity: metric.cvssV4_0.baseSeverity || "UNKNOWN",
            vector: metric.cvssV4_0.vectorString,
            source,
          });
        }
        if (metric.cvssV3_1) {
          allRaw.push({
            version: "3.1",
            baseScore: metric.cvssV3_1.baseScore,
            severity: metric.cvssV3_1.baseSeverity || "UNKNOWN",
            vector: metric.cvssV3_1.vectorString,
            source,
          });
        }
        if (metric.cvssV3_0) {
          allRaw.push({
            version: "3.0",
            baseScore: metric.cvssV3_0.baseScore,
            severity: metric.cvssV3_0.baseSeverity || "UNKNOWN",
            vector: metric.cvssV3_0.vectorString,
            source,
          });
        }
        if (metric.cvssV2_0) {
          allRaw.push({
            version: "2.0",
            baseScore: metric.cvssV2_0.baseScore,
            severity: metric.cvssV2_0.baseSeverity || "UNKNOWN",
            vector: metric.cvssV2_0.vectorString,
            source,
          });
        }
      }
    }

    const best = allRaw.sort((a, b) => {
      const versionOrder = { "4.0": 4, "3.1": 3, "3.0": 2, "2.0": 1 };
      return (versionOrder[b.version as keyof typeof versionOrder] || 0) - (versionOrder[a.version as keyof typeof versionOrder] || 0);
    })[0] || null;

    return { best, allRaw };
  }

  private mergeWeakness(containers: CveContainer[]) {
    const weakness: NormalizedCveDocument["weakness"] = [];

    for (const container of containers) {
      for (const problem of container.problemTypes || []) {
        for (const desc of problem.descriptions) {
          if (desc.cweId) {
            weakness.push({
              cweId: desc.cweId,
              description: desc.description,
            });
          }
        }
      }
    }

    return weakness;
  }

  private mergeAffected(containers: CveContainer[]) {
    const cpe: NormalizedCveDocument["affected"]["cpe"] = [];
    const packages: NormalizedCveDocument["affected"]["packages"] = [];

    for (const container of containers) {
      for (const aff of container.affected || []) {
        // Extract CPEs
        for (const cpeUri of aff.cpes || []) {
          const parsed = this.parseCpe(cpeUri);
          if (parsed) {
            cpe.push({
              uri: cpeUri,
              vendor: parsed.vendor,
              product: parsed.product,
              version: parsed.version,
              versionStartIncluding: null,
              versionEndExcluding: null,
              vulnerable: true,
            });
          }
        }

        // Extract package info
        if (aff.vendor && aff.product) {
          const ranges = (aff.versions || []).map((v) => v.version);
          packages.push({
            ecosystem: aff.vendor,
            name: aff.product,
            ranges,
          });
        }
      }
    }

    return { cpe, packages };
  }

  private parseCpe(cpeUri: string): { vendor: string; product: string; version: string } | null {
    const parts = cpeUri.split(":");
    if (parts.length < 6) return null;

    return {
      vendor: parts[3] || "*",
      product: parts[4] || "*",
      version: parts[5] || "*",
    };
  }

  private extractKevFromAdp(containers: CveContainer[]): NormalizedCveDocument["kev"] {
    void containers;
    // Look for KEV info in ADP containers
    // This is a simplified implementation - full version would parse ADP metadata
    return {
      flag: false,
      dateAdded: null,
      dueDate: null,
      requiredAction: null,
      vulnerabilityName: null,
      notes: null,
      ransomwareUse: null,
    };
  }
}
