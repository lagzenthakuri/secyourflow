import { createHash } from "crypto";

export interface RateLimiter {
  acquire(): Promise<void>;
}

export class TokenBucketRateLimiter implements RateLimiter {
  private tokens: number;
  private lastRefill: number;
  private readonly maxTokens: number;
  private readonly refillRate: number; // tokens per ms
  private readonly queue: Array<() => void> = [];

  constructor(requestsPer30Seconds: number) {
    this.maxTokens = requestsPer30Seconds;
    this.tokens = requestsPer30Seconds;
    this.refillRate = requestsPer30Seconds / 30000; // per millisecond
    this.lastRefill = Date.now();
  }

  async acquire(): Promise<void> {
    this.refill();
    
    if (this.tokens >= 1) {
      this.tokens -= 1;
      return Promise.resolve();
    }

    return new Promise<void>((resolve) => {
      this.queue.push(resolve);
      this.scheduleRefill();
    });
  }

  private refill(): void {
    const now = Date.now();
    const elapsed = now - this.lastRefill;
    const tokensToAdd = elapsed * this.refillRate;
    
    this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }

  private scheduleRefill(): void {
    if (this.queue.length === 0) return;

    const timeToNextToken = (1 - this.tokens) / this.refillRate;
    
    setTimeout(() => {
      this.refill();
      
      while (this.queue.length > 0 && this.tokens >= 1) {
        const resolve = this.queue.shift();
        this.tokens -= 1;
        resolve?.();
      }
      
      if (this.queue.length > 0) {
        this.scheduleRefill();
      }
    }, Math.max(0, timeToNextToken));
  }
}

export interface RetryConfig {
  maxRetries: number;
  baseBackoffMs: number;
  maxBackoffMs: number;
  retryableStatuses: number[];
}

const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxRetries: 3,
  baseBackoffMs: 1000,
  maxBackoffMs: 30000,
  retryableStatuses: [429, 500, 502, 503, 504],
};

function deterministicJitter(baseMs: number, attempt: number): number {
  const exponential = baseMs * Math.pow(2, attempt);
  const jitter = exponential * 0.1 * Math.sin(attempt);
  return Math.floor(exponential + jitter);
}

export interface HttpClientOptions {
  rateLimiter?: RateLimiter;
  retryConfig?: Partial<RetryConfig>;
  timeoutMs?: number;
  headers?: Record<string, string>;
}

export class HttpClient {
  private readonly rateLimiter?: RateLimiter;
  private readonly retryConfig: RetryConfig;
  private readonly timeoutMs: number;
  private readonly defaultHeaders: Record<string, string>;

  constructor(options: HttpClientOptions = {}) {
    this.rateLimiter = options.rateLimiter;
    this.retryConfig = { ...DEFAULT_RETRY_CONFIG, ...options.retryConfig };
    this.timeoutMs = options.timeoutMs || 30000;
    this.defaultHeaders = options.headers || {};
  }

  async fetch<T = unknown>(
    url: string,
    options: RequestInit = {}
  ): Promise<{ data: T; status: number; headers: Headers }> {
    if (this.rateLimiter) {
      await this.rateLimiter.acquire();
    }

    let lastError: Error | null = null;

    for (let attempt = 0; attempt <= this.retryConfig.maxRetries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeoutMs);

        const response = await fetch(url, {
          ...options,
          headers: {
            ...this.defaultHeaders,
            ...options.headers,
          },
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (response.ok) {
          const data = await response.json();
          return {
            data: data as T,
            status: response.status,
            headers: response.headers,
          };
        }

        if (this.retryConfig.retryableStatuses.includes(response.status) && attempt < this.retryConfig.maxRetries) {
          const backoffMs = Math.min(
            deterministicJitter(this.retryConfig.baseBackoffMs, attempt),
            this.retryConfig.maxBackoffMs
          );
          await new Promise((resolve) => setTimeout(resolve, backoffMs));
          continue;
        }

        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));

        if (attempt < this.retryConfig.maxRetries) {
          const backoffMs = Math.min(
            deterministicJitter(this.retryConfig.baseBackoffMs, attempt),
            this.retryConfig.maxBackoffMs
          );
          await new Promise((resolve) => setTimeout(resolve, backoffMs));
          continue;
        }
      }
    }

    throw lastError || new Error("Request failed after retries");
  }
}

export function hashJson(data: unknown): string {
  const normalized = JSON.stringify(data, Object.keys(data as object).sort());
  return createHash("sha256").update(normalized).digest("hex");
}

export function normalizeUrl(url: string): string {
  try {
    const parsed = new URL(url);
    
    // Lowercase scheme and host
    parsed.protocol = parsed.protocol.toLowerCase();
    parsed.hostname = parsed.hostname.toLowerCase();
    
    // Remove default ports
    if (
      (parsed.protocol === "http:" && parsed.port === "80") ||
      (parsed.protocol === "https:" && parsed.port === "443")
    ) {
      parsed.port = "";
    }
    
    // Remove common tracking params
    const trackingParams = ["utm_source", "utm_medium", "utm_campaign", "utm_term", "utm_content", "fbclid"];
    trackingParams.forEach((param) => parsed.searchParams.delete(param));
    
    return parsed.toString();
  } catch {
    return url;
  }
}
