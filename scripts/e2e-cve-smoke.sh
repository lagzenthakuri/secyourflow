#!/usr/bin/env bash
set -euo pipefail

BASE_URL="${BASE_URL:-http://localhost:3000}"
TIMEOUT_SECONDS="${TIMEOUT_SECONDS:-20}"
TMP_DIR="$(mktemp -d)"
FAILURES=0
PASSES=0
API_METHOD=""

cleanup() {
  rm -rf "$TMP_DIR"
}
trap cleanup EXIT

pass() {
  PASSES=$((PASSES + 1))
  printf 'PASS: %s\n' "$1"
}

fail() {
  FAILURES=$((FAILURES + 1))
  printf 'FAIL: %s\n' "$1"
}

fatal() {
  printf 'FAIL: %s\n' "$1"
  printf 'Action: start the app with `npm run dev` and re-run this script.\n'
  exit 2
}

html_request() {
  local path="$1"
  local out="$2"
  curl -sS --max-time "$TIMEOUT_SECONDS" -o "$out" -w '%{http_code}' "${BASE_URL}${path}" || printf '000'
}

probe_api_method() {
  local probe_query="q=CVE-2018-6341&page=1&pageSize=5&mode=auto"
  local get_code post_code

  get_code="$(curl -sS --max-time "$TIMEOUT_SECONDS" -o "$TMP_DIR/api-probe-get.json" -w '%{http_code}' "${BASE_URL}/api/cves/search?${probe_query}" || printf '000')"
  if [ "$get_code" = "200" ]; then
    API_METHOD="GET"
    return
  fi

  post_code="$(curl -sS --max-time "$TIMEOUT_SECONDS" -X POST -H 'Accept: application/json' -o "$TMP_DIR/api-probe-post.json" -w '%{http_code}' "${BASE_URL}/api/cves/search?${probe_query}" || printf '000')"
  if [ "$post_code" = "200" ]; then
    API_METHOD="POST"
    return
  fi

  fatal "Cannot access /api/cves/search (GET=${get_code}, POST=${post_code})"
}

api_request() {
  local query="$1"
  local out="$2"
  local url="${BASE_URL}/api/cves/search?${query}"

  if [ "$API_METHOD" = "POST" ]; then
    curl -sS --max-time "$TIMEOUT_SECONDS" -X POST -H 'Accept: application/json' -o "$out" -w '%{http_code}' "$url" || printf '000'
  else
    curl -sS --max-time "$TIMEOUT_SECONDS" -o "$out" -w '%{http_code}' "$url" || printf '000'
  fi
}

assert_server_reachable() {
  local status
  status="$(html_request "/cves?page=1" "$TMP_DIR/reachability.html")"
  if [ "$status" != "200" ]; then
    fatal "Server not reachable at ${BASE_URL}/cves (HTTP ${status})"
  fi
  pass "Server reachable at ${BASE_URL}"
}

assert_api_contract() {
  local body="$TMP_DIR/api-contract.json"
  local status
  status="$(api_request "q=React&page=1&pageSize=20&mode=product" "$body")"
  if [ "$status" != "200" ]; then
    fail "API contract request failed (HTTP ${status})"
    return
  fi

  if grep -Eq '"meta"[[:space:]]*:' "$body" && grep -Eq '"data"[[:space:]]*:' "$body"; then
    pass "API response includes meta + data"
  else
    fail "API response missing meta or data keys"
  fi

  if grep -Eq '"cveId"[[:space:]]*:[[:space:]]*"CVE-[0-9]{4}-[0-9]{4,}"' "$body" \
    && grep -Eq '"description"[[:space:]]*:[[:space:]]*"' "$body"; then
    pass "API entries include cveId + description fields"
  else
    fail "API entries missing cveId and/or description fields"
  fi
}

assert_react_product_semantics() {
  local body="$TMP_DIR/react-product.json"
  local status
  status="$(api_request "q=React&page=1&pageSize=50&mode=product" "$body")"
  if [ "$status" != "200" ]; then
    fail "React product search failed (HTTP ${status})"
    return
  fi

  if grep -Eq 'CVE-2018-6341|CVE-2018-6342' "$body"; then
    pass "React product search includes CVE-2018-6341 or CVE-2018-6342"
  else
    fail "React product search missing CVE-2018-6341/CVE-2018-6342"
  fi

  if grep -Eq 'CVE-2007-1724' "$body"; then
    fail "React product search incorrectly includes CVE-2007-1724 collision"
  else
    pass "React product search excludes CVE-2007-1724 collision"
  fi

  local html_status
  html_status="$(html_request "/cves?q=React&page=1&mode=product" "$TMP_DIR/react-product.html")"
  if [ "$html_status" = "200" ]; then
    pass "Client page /cves?q=React&page=1&mode=product reachable"
  else
    fail "Client page /cves?q=React&page=1&mode=product failed (HTTP ${html_status})"
  fi
}

assert_reactos_semantics() {
  local id_check="$TMP_DIR/reactos-by-id.json"
  local search_body="$TMP_DIR/reactos-product.json"
  local id_status search_status

  id_status="$(api_request "q=CVE-2007-1724&page=1&pageSize=5&mode=auto" "$id_check")"
  search_status="$(api_request "q=ReactOS&page=1&pageSize=50&mode=product" "$search_body")"

  if [ "$search_status" != "200" ]; then
    fail "ReactOS product search failed (HTTP ${search_status})"
    return
  fi

  if grep -Eq 'CVE-2007-1724' "$id_check"; then
    if grep -Eq 'CVE-2007-1724' "$search_body"; then
      pass "ReactOS product search allows CVE-2007-1724 when present"
    else
      fail "ReactOS product search did not include CVE-2007-1724 even though by-id lookup found it"
    fi
  else
    pass "CVE-2007-1724 not currently returned by upstream; ReactOS allowance check skipped"
  fi

  local html_status
  html_status="$(html_request "/cves?q=ReactOS&page=1&mode=product" "$TMP_DIR/reactos-product.html")"
  if [ "$html_status" = "200" ]; then
    pass "Client page /cves?q=ReactOS&page=1&mode=product reachable"
  else
    fail "Client page /cves?q=ReactOS&page=1&mode=product failed (HTTP ${html_status})"
  fi
}

assert_exact_cve_semantics() {
  local body="$TMP_DIR/cve-exact.json"
  local status
  status="$(api_request "q=CVE-2018-6341&page=1&pageSize=20&mode=auto" "$body")"
  if [ "$status" != "200" ]; then
    fail "Exact CVE lookup failed (HTTP ${status})"
    return
  fi

  if grep -Eq 'CVE-2018-6341' "$body"; then
    pass "Exact query /api/cves/search?q=CVE-2018-6341 returns CVE-2018-6341"
  else
    fail "Exact query /api/cves/search?q=CVE-2018-6341 did not return CVE-2018-6341"
  fi

  local html_status
  html_status="$(html_request "/cves?q=CVE-2018-6341&page=1" "$TMP_DIR/cve-exact.html")"
  if [ "$html_status" = "200" ]; then
    pass "Client page /cves?q=CVE-2018-6341&page=1 reachable"
  else
    fail "Client page /cves?q=CVE-2018-6341&page=1 failed (HTTP ${html_status})"
  fi
}

assert_empty_query_behavior() {
  local html="$TMP_DIR/empty-query.html"
  local json="$TMP_DIR/empty-query.json"
  local html_status api_status current_year min_allowed oldest_year years

  html_status="$(html_request "/cves?page=1" "$html")"
  if [ "$html_status" != "200" ]; then
    fail "Empty query client page failed (HTTP ${html_status})"
    return
  fi

  if grep -Fq 'trending/recent results shown because query is empty' "$html"; then
    fail "Empty query page still shows deprecated trending placeholder text"
  else
    pass "Empty query page does not show deprecated trending placeholder"
  fi

  if grep -Eq 'CVE-1999-0082' "$html"; then
    fail "Empty query client page contains CVE-1999-0082"
  else
    pass "Empty query client page excludes CVE-1999-0082"
  fi

  api_status="$(api_request "page=1&pageSize=20&mode=auto" "$json")"
  if [ "$api_status" != "200" ]; then
    fail "Empty query API request failed (HTTP ${api_status})"
    return
  fi

  if grep -Eq 'CVE-1999-0082' "$json"; then
    fail "Empty query API contains CVE-1999-0082"
  else
    pass "Empty query API excludes CVE-1999-0082"
  fi

  if grep -Fq 'trending/recent results shown because query is empty' "$json"; then
    fail "Empty query API still emits deprecated trending placeholder text"
  else
    pass "Empty query API does not emit deprecated trending placeholder text"
  fi

  if grep -Eq '"data"[[:space:]]*:[[:space:]]*\[[[:space:]]*\]' "$json"; then
    pass "Empty query API returns empty data set"
    return
  fi

  current_year="$(date +%Y)"
  min_allowed=$((current_year - 1))
  years="$(grep -Eo 'CVE-[0-9]{4}-[0-9]{4,}' "$json" | awk -F- '{print $2}' | sort -u || true)"
  if [ -z "$years" ]; then
    fail "Empty query API returned non-empty payload but no CVE IDs were parseable"
    return
  fi

  oldest_year="$(printf '%s\n' "$years" | awk 'NR==1 {min=$1} $1<min {min=$1} END {print min}')"
  if [ "$oldest_year" -lt "$min_allowed" ]; then
    fail "Empty query API returned non-recent CVEs (oldest year ${oldest_year}, expected >= ${min_allowed})"
  else
    pass "Empty query API non-empty results are recent-only"
  fi
}

printf 'Running CVE E2E smoke tests against %s\n' "$BASE_URL"
assert_server_reachable
probe_api_method
pass "Detected /api/cves/search method: ${API_METHOD}"
assert_api_contract
assert_react_product_semantics
assert_reactos_semantics
assert_exact_cve_semantics
assert_empty_query_behavior

printf '\nSummary: %d PASS, %d FAIL\n' "$PASSES" "$FAILURES"
if [ "$FAILURES" -gt 0 ]; then
  exit 1
fi
